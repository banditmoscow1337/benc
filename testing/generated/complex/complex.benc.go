// Code generated by bencgen golang. DO NOT EDIT.
// source: schemas/complex.benc

package complex

import (
    "go.kine.bz/benc/std"
    "go.kine.bz/benc/impl/gen"
)

// Struct - E
type E struct {
    EID int32
    Description string
}

// Reserved Ids - E
var eRIds = []uint16{}

// Size - E
func (e *E) Size() int {
    return e.size(0)
}

// Nested Size - E
func (e *E) size(id uint16) (s int) {
    s += bstd.SizeInt32() + 2
    s += bstd.SizeString(e.Description) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - E
func (e *E) SizePlain() (s int) {
    s += bstd.SizeInt32()
    s += bstd.SizeString(e.Description)
    return
}

// Marshal - E
func (e *E) Marshal(b []byte) {
    e.marshal(0, b, 0)
}

// Nested Marshal - E
func (e *E) marshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed32, 1)
    n = bstd.MarshalInt32(n, b, e.EID)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 2)
    n = bstd.MarshalString(n, b, e.Description)

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - E
func (e *E) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalInt32(n, b, e.EID)
    n = bstd.MarshalString(n, b, e.Description)
    return n
}

// Unmarshal - E
func (e *E) Unmarshal(b []byte) (err error) {
    _, err = e.unmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - E
func (e *E) unmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, eRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, e.EID, err = bstd.UnmarshalInt32(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, eRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, e.Description, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - E
func (e *E) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, e.EID, err = bstd.UnmarshalInt32(n, b); err != nil {
        return
    }
    if n, e.Description, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    return
}

// Struct - D
type D struct {
    Timestamp uint32
    Note string
    Events []E
}

// Reserved Ids - D
var dRIds = []uint16{}

// Size - D
func (d *D) Size() int {
    return d.size(0)
}

// Nested Size - D
func (d *D) size(id uint16) (s int) {
    s += bstd.SizeUInt32() + 2
    s += bstd.SizeString(d.Note) + 2
    s += bstd.SizeSlice(d.Events, func (s E) int { return s.SizePlain() }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - D
func (d *D) SizePlain() (s int) {
    s += bstd.SizeUInt32()
    s += bstd.SizeString(d.Note)
    s += bstd.SizeSlice(d.Events, func (s E) int { return s.SizePlain() })
    return
}

// Marshal - D
func (d *D) Marshal(b []byte) {
    d.marshal(0, b, 0)
}

// Nested Marshal - D
func (d *D) marshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed32, 1)
    n = bstd.MarshalUInt32(n, b, d.Timestamp)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 2)
    n = bstd.MarshalString(n, b, d.Note)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Array, 3)
    n = bstd.MarshalSlice(n, b, d.Events, func (n int, b []byte, s E) int { return s.MarshalPlain(n, b) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - D
func (d *D) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalUInt32(n, b, d.Timestamp)
    n = bstd.MarshalString(n, b, d.Note)
    n = bstd.MarshalSlice(n, b, d.Events, func (n int, b []byte, s E) int { return s.MarshalPlain(n, b) })
    return n
}

// Unmarshal - D
func (d *D) Unmarshal(b []byte) (err error) {
    _, err = d.unmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - D
func (d *D) unmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, dRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, d.Timestamp, err = bstd.UnmarshalUInt32(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, dRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, d.Note, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, dRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, d.Events, err = bstd.UnmarshalSlice[E](n, b, func (n int, b []byte, s *E) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - D
func (d *D) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, d.Timestamp, err = bstd.UnmarshalUInt32(n, b); err != nil {
        return
    }
    if n, d.Note, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, d.Events, err = bstd.UnmarshalSlice[E](n, b, func (n int, b []byte, s *E) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    return
}

// Struct - C
type C struct {
    Value float64
    Measurements []D
}

// Reserved Ids - C
var cRIds = []uint16{}

// Size - C
func (c *C) Size() int {
    return c.size(0)
}

// Nested Size - C
func (c *C) size(id uint16) (s int) {
    s += bstd.SizeFloat64() + 2
    s += bstd.SizeSlice(c.Measurements, func (s D) int { return s.SizePlain() }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - C
func (c *C) SizePlain() (s int) {
    s += bstd.SizeFloat64()
    s += bstd.SizeSlice(c.Measurements, func (s D) int { return s.SizePlain() })
    return
}

// Marshal - C
func (c *C) Marshal(b []byte) {
    c.marshal(0, b, 0)
}

// Nested Marshal - C
func (c *C) marshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 1)
    n = bstd.MarshalFloat64(n, b, c.Value)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Array, 2)
    n = bstd.MarshalSlice(n, b, c.Measurements, func (n int, b []byte, s D) int { return s.MarshalPlain(n, b) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - C
func (c *C) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalFloat64(n, b, c.Value)
    n = bstd.MarshalSlice(n, b, c.Measurements, func (n int, b []byte, s D) int { return s.MarshalPlain(n, b) })
    return n
}

// Unmarshal - C
func (c *C) Unmarshal(b []byte) (err error) {
    _, err = c.unmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - C
func (c *C) unmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, cRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, c.Value, err = bstd.UnmarshalFloat64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, cRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, c.Measurements, err = bstd.UnmarshalSlice[D](n, b, func (n int, b []byte, s *D) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - C
func (c *C) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, c.Value, err = bstd.UnmarshalFloat64(n, b); err != nil {
        return
    }
    if n, c.Measurements, err = bstd.UnmarshalSlice[D](n, b, func (n int, b []byte, s *D) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    return
}

// Struct - BB
type BB struct {
    IsActive bool
    Details [][]C
}

// Reserved Ids - BB
var bBRIds = []uint16{}

// Size - BB
func (bB *BB) Size() int {
    return bB.size(0)
}

// Nested Size - BB
func (bB *BB) size(id uint16) (s int) {
    s += bstd.SizeBool() + 2
    s += bstd.SizeSlice(bB.Details, func (s []C) int { return bstd.SizeSlice(s, func (s C) int { return s.SizePlain() }) }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - BB
func (bB *BB) SizePlain() (s int) {
    s += bstd.SizeBool()
    s += bstd.SizeSlice(bB.Details, func (s []C) int { return bstd.SizeSlice(s, func (s C) int { return s.SizePlain() }) })
    return
}

// Marshal - BB
func (bB *BB) Marshal(b []byte) {
    bB.marshal(0, b, 0)
}

// Nested Marshal - BB
func (bB *BB) marshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed8, 1)
    n = bstd.MarshalBool(n, b, bB.IsActive)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Array, 2)
    n = bstd.MarshalSlice(n, b, bB.Details, func (n int, b []byte, s []C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s C) int { return s.MarshalPlain(n, b) }) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - BB
func (bB *BB) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalBool(n, b, bB.IsActive)
    n = bstd.MarshalSlice(n, b, bB.Details, func (n int, b []byte, s []C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s C) int { return s.MarshalPlain(n, b) }) })
    return n
}

// Unmarshal - BB
func (bB *BB) Unmarshal(b []byte) (err error) {
    _, err = bB.unmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - BB
func (bB *BB) unmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, bBRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, bB.IsActive, err = bstd.UnmarshalBool(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, bBRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, bB.Details, err = bstd.UnmarshalSlice[[]C](n, b, func (n int, b []byte) (int, []C, error) { return bstd.UnmarshalSlice[C](n, b, func (n int, b []byte, s *C) (int, error) { return s.UnmarshalPlain(n, b) }) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - BB
func (bB *BB) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, bB.IsActive, err = bstd.UnmarshalBool(n, b); err != nil {
        return
    }
    if n, bB.Details, err = bstd.UnmarshalSlice[[]C](n, b, func (n int, b []byte) (int, []C, error) { return bstd.UnmarshalSlice[C](n, b, func (n int, b []byte, s *C) (int, error) { return s.UnmarshalPlain(n, b) }) }); err != nil {
        return
    }
    return
}

// Struct - A
type A struct {
    Id int64
    Name string
    SubItems []BB
    ComplexData [][][]C
}

// Reserved Ids - A
var aRIds = []uint16{}

// Size - A
func (a *A) Size() int {
    return a.size(0)
}

// Nested Size - A
func (a *A) size(id uint16) (s int) {
    s += bstd.SizeInt64() + 2
    s += bstd.SizeString(a.Name) + 2
    s += bstd.SizeSlice(a.SubItems, func (s BB) int { return s.SizePlain() }) + 2
    s += bstd.SizeSlice(a.ComplexData, func (s [][]C) int { return bstd.SizeSlice(s, func (s []C) int { return bstd.SizeSlice(s, func (s C) int { return s.SizePlain() }) }) }) + 2

    if id > 255 {
        s += 5
        return
    }
    s += 4
    return
}

// SizePlain - A
func (a *A) SizePlain() (s int) {
    s += bstd.SizeInt64()
    s += bstd.SizeString(a.Name)
    s += bstd.SizeSlice(a.SubItems, func (s BB) int { return s.SizePlain() })
    s += bstd.SizeSlice(a.ComplexData, func (s [][]C) int { return bstd.SizeSlice(s, func (s []C) int { return bstd.SizeSlice(s, func (s C) int { return s.SizePlain() }) }) })
    return
}

// Marshal - A
func (a *A) Marshal(b []byte) {
    a.marshal(0, b, 0)
}

// Nested Marshal - A
func (a *A) marshal(tn int, b []byte, id uint16) (n int) {
    n = bgenimpl.MarshalTag(tn, b, bgenimpl.Container, id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Fixed64, 1)
    n = bstd.MarshalInt64(n, b, a.Id)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Bytes, 2)
    n = bstd.MarshalString(n, b, a.Name)
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Array, 3)
    n = bstd.MarshalSlice(n, b, a.SubItems, func (n int, b []byte, s BB) int { return s.MarshalPlain(n, b) })
    n = bgenimpl.MarshalTag(n, b, bgenimpl.Array, 4)
    n = bstd.MarshalSlice(n, b, a.ComplexData, func (n int, b []byte, s [][]C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s []C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s C) int { return s.MarshalPlain(n, b) }) }) })

    n += 2
    b[n-2] = 1
    b[n-1] = 1
    return
}

// MarshalPlain - A
func (a *A) MarshalPlain(tn int, b []byte) (n int) {
    n = tn
    n = bstd.MarshalInt64(n, b, a.Id)
    n = bstd.MarshalString(n, b, a.Name)
    n = bstd.MarshalSlice(n, b, a.SubItems, func (n int, b []byte, s BB) int { return s.MarshalPlain(n, b) })
    n = bstd.MarshalSlice(n, b, a.ComplexData, func (n int, b []byte, s [][]C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s []C) int { return bstd.MarshalSlice(n, b, s, func (n int, b []byte, s C) int { return s.MarshalPlain(n, b) }) }) })
    return n
}

// Unmarshal - A
func (a *A) Unmarshal(b []byte) (err error) {
    _, err = a.unmarshal(0, b, []uint16{}, 0)
    return
}

// Nested Unmarshal - A
func (a *A) unmarshal(tn int, b []byte, r []uint16, id uint16) (n int, err error) {
    var ok bool
    if n, ok, err = bgenimpl.HandleCompatibility(tn, b, r, id); !ok {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, aRIds, 1); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, a.Id, err = bstd.UnmarshalInt64(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, aRIds, 2); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, a.Name, err = bstd.UnmarshalString(n, b); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, aRIds, 3); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, a.SubItems, err = bstd.UnmarshalSlice[BB](n, b, func (n int, b []byte, s *BB) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
            return
        }
    }
    if n, ok, err = bgenimpl.HandleCompatibility(n, b, aRIds, 4); err != nil {
        if err == bgenimpl.ErrEof {
            return n, nil
        }
        return
    }
    if ok {
        if n, a.ComplexData, err = bstd.UnmarshalSlice[[][]C](n, b, func (n int, b []byte) (int, [][]C, error) { return bstd.UnmarshalSlice[[]C](n, b, func (n int, b []byte) (int, []C, error) { return bstd.UnmarshalSlice[C](n, b, func (n int, b []byte, s *C) (int, error) { return s.UnmarshalPlain(n, b) }) }) }); err != nil {
            return
        }
    }
    n += 2
    return
}

// UnmarshalPlain - A
func (a *A) UnmarshalPlain(tn int, b []byte) (n int, err error) {
    n = tn
    if n, a.Id, err = bstd.UnmarshalInt64(n, b); err != nil {
        return
    }
    if n, a.Name, err = bstd.UnmarshalString(n, b); err != nil {
        return
    }
    if n, a.SubItems, err = bstd.UnmarshalSlice[BB](n, b, func (n int, b []byte, s *BB) (int, error) { return s.UnmarshalPlain(n, b) }); err != nil {
        return
    }
    if n, a.ComplexData, err = bstd.UnmarshalSlice[[][]C](n, b, func (n int, b []byte) (int, [][]C, error) { return bstd.UnmarshalSlice[[]C](n, b, func (n int, b []byte) (int, []C, error) { return bstd.UnmarshalSlice[C](n, b, func (n int, b []byte, s *C) (int, error) { return s.UnmarshalPlain(n, b) }) }) }); err != nil {
        return
    }
    return
}

