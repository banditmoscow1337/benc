package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// fixedSizeTypes is a map of Go types that have a fixed marshalled size.
var fixedSizeTypes = map[string]bool{
	"bool": true, "byte": true, "rune": true, "int8": true, "uint8": true,
	"int16": true, "uint16": true, "int32": true, "uint32": true,
	"int64": true, "uint64": true, "float32": true, "float64": true,
}

// Generator holds the state of the generation process.
type Generator struct {
	pkgName   string
	buf       bytes.Buffer
	typeSpecs map[string]*ast.TypeSpec
}

// NewGenerator creates a new generator for the given package name.
func NewGenerator(pkgName string) *Generator {
	return &Generator{
		pkgName:   pkgName,
		typeSpecs: make(map[string]*ast.TypeSpec),
	}
}

// isUnsupportedType recursively checks if a type expression contains an ignored type.
func (g *Generator) isUnsupportedType(expr ast.Expr) bool {
	switch t := expr.(type) {
	case *ast.Ident:
		// Check for named unsupported types.
		switch t.Name {
		case "any", "complex64", "complex128":
			return true
		default:
			// If the identifier is a custom type, we need to look up its definition.
			if ts, ok := g.typeSpecs[t.Name]; ok {
				return g.isUnsupportedType(ts.Type)
			}
			return false
		}

	case *ast.InterfaceType:
		// Check for the empty interface: interface{}
		return t.Methods == nil || len(t.Methods.List) == 0

	case *ast.ArrayType:
		// If the element type is unsupported, the slice is unsupported.
		return g.isUnsupportedType(t.Elt)

	case *ast.MapType:
		// If either the key or value type is unsupported, the map is unsupported.
		return g.isUnsupportedType(t.Key) || g.isUnsupportedType(t.Value)

	case *ast.StarExpr:
		// Check the underlying type for pointers.
		return g.isUnsupportedType(t.X)

	default:
		return false
	}
}

// Generate produces the benc serialization code for the given types.
func (g *Generator) Generate(types []*ast.TypeSpec) (string, error) {
	g.buf.Reset()
	g.preprocessTypes(types)

	g.printf("// Code generated by benc generator; DO NOT EDIT.\n\n")
	g.printf("package %s\n\n", g.pkgName)
	g.printf("import (\n")
	g.printf("\tbstd \"github.com/banditmoscow1337/benc/std\"\n")
	g.printf(")\n\n")

	for _, ts := range types {
		if err := g.generateMethods(ts); err != nil {
			return "", fmt.Errorf("generating methods for %s: %w", ts.Name.Name, err)
		}
	}

	return g.format()
}

// GenerateTests produces the test code for the given types.
func (g *Generator) GenerateTests(types []*ast.TypeSpec) (string, error) {
	g.buf.Reset()
	g.preprocessTypes(types)

	g.printf("// Code generated by benc generator; DO NOT EDIT.\n\n")
	g.printf("package %s\n\n", g.pkgName)
	g.printf("import (\n")
	g.printf("\t\"math/rand\"\n")
	g.printf("\t\"testing\"\n")
	g.printf("\t\"time\"\n\n")
	g.printf("\tbtst \"github.com/banditmoscow1337/benc/gen\"\n")
	g.printf(")\n\n")

	for _, ts := range types {
		g.generateTestGenerator(ts)
		g.generateTestComparer(ts)
	}

	// Find the first top-level struct to be the main test subject.
	var topLevelStruct *ast.TypeSpec
	for _, ts := range types {
		if _, ok := ts.Type.(*ast.StructType); ok {
			if topLevelStruct == nil {
				topLevelStruct = ts
			}
		}
	}

	if topLevelStruct != nil {
		g.generateTestMain(topLevelStruct)
	}

	return g.format()
}

// --- Method Generation ---

func (g *Generator) preprocessTypes(types []*ast.TypeSpec) {
	for _, t := range types {
		g.typeSpecs[t.Name.Name] = t
	}
}

func (g *Generator) generateMethods(ts *ast.TypeSpec) error {
	switch ts.Type.(type) {
	case *ast.StructType:
		return g.generateStructMethods(ts)
	case *ast.MapType:
		return g.generateMapAliasMethods(ts)
	}
	return nil
}

func (g *Generator) generateStructMethods(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	// Use a descriptive, camelCase receiver name to avoid conflicts.
	receiver := strings.ToLower(name[:1]) + name[1:]

	// Pre-filter fields to exclude unsupported types.
	var supportedFields []*ast.Field
	for _, field := range ts.Type.(*ast.StructType).Fields.List {
		if g.isUnsupportedType(field.Type) {
			for _, fName := range field.Names {
				log.Printf("INFO: Skipping unsupported field %s.%s with type %s", name, fName.Name, g.exprToString(field.Type))
			}
			continue
		}
		supportedFields = append(supportedFields, field)
	}

	g.printf("func (%s *%s) Size() (s int) {\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\ts += %s\n", g.getSizeExpr(field.Type, fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn\n}\n\n")

	g.printf("func (%s *%s) Marshal(tn int, b []byte) (n int) {\n\tn = tn\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\tn = %s\n", g.getMarshalExpr(field.Type, "n", "b", fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn n\n}\n\n")

	g.printf("func (%s *%s) Unmarshal(tn int, b []byte) (n int, err error) {\n\tn = tn\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\tif %s; err != nil {\n\t\treturn\n\t}\n", g.getUnmarshalExpr(field.Type, "n", "b", fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn\n}\n\n")
	return nil
}

func (g *Generator) generateMapAliasMethods(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	// Use a descriptive, camelCase receiver name to avoid conflicts.
	receiver := strings.ToLower(name[:1]) + name[1:]
	mapType := ts.Type.(*ast.MapType)

	// Check if the map alias itself uses unsupported types.
	if g.isUnsupportedType(mapType) {
		log.Printf("INFO: Skipping generation for map alias %s because it uses unsupported types.", name)
		return nil
	}

	g.printf("func (%s *%s) Size() (s int) {\n", receiver, name)
	g.printf("\ts += %s\n", g.getSizeExpr(mapType, "*"+receiver))
	g.printf("\treturn\n}\n\n")

	g.printf("func (%s *%s) Marshal(tn int, b []byte) (n int) {\n\tn = tn\n", receiver, name)
	g.printf("\tn = %s\n", g.getMarshalExpr(mapType, "n", "b", "*"+receiver))
	g.printf("\treturn\n}\n\n")

	g.printf("func (%s *%s) Unmarshal(tn int, b []byte) (n int, err error) {\n\tn = tn\n", receiver, name)
	g.printf("\tif %s; err != nil {\n\t\treturn\n\t}\n", g.getUnmarshalExpr(mapType, "n", "b", "*"+receiver))
	g.printf("\treturn\n}\n\n")
	return nil
}

// --- Expression Logic ---

// typeGenInfo holds basic information about a type for code generation.
type typeGenInfo struct {
	TypeName      string
	Marshaler     string
	Unmarshaler   string
	TestGenerator string
	TestComparer  string
	IsFixedSize   bool
}

// getTypeInfo extracts basic generation info for a given AST expression.
func (g *Generator) getTypeInfo(expr ast.Expr) typeGenInfo {
	typeName := g.exprToString(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		// Case 1: It's a custom type defined in the same package.
		if _, ok := g.typeSpecs[t.Name]; ok {
			return typeGenInfo{
				TypeName:      t.Name,
				TestGenerator: fmt.Sprintf("Generate%s", t.Name),
				TestComparer:  fmt.Sprintf("Compare%s", t.Name),
			}
		}

		// Case 2: It's a primitive Go type.
		title := strings.Title(t.Name)
		// Handle special cases for byte and rune aliases.
		if t.Name == "byte" || t.Name == "uint8" {
			title = "Byte"
			typeName = "byte" // Standardize on 'byte' for consistency.
		}
		if t.Name == "rune" {
			title = "Int32"
			typeName = "rune"
		}

		return typeGenInfo{
			TypeName:      typeName,
			Marshaler:     "bstd.Marshal" + title,
			Unmarshaler:   "bstd.Unmarshal" + title,
			TestGenerator: "btst.Generate" + title,
			TestComparer:  fmt.Sprintf("btst.ComparePrimitive[%s]", typeName),
			IsFixedSize:   fixedSizeTypes[t.Name],
		}

	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		return typeGenInfo{
			TypeName:      typeName,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) %s { return btst.GenerateSlice(r, d, %s) }", typeName, eltInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("func(a, b %s) error { return btst.CompareSlice(a, b, %s) }", typeName, eltInfo.TestComparer),
		}

	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		return typeGenInfo{
			TypeName:      typeName,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) %s { return btst.GenerateMap(r, d, %s, %s) }", typeName, keyInfo.TestGenerator, valInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("func(a, b %s) error { return btst.CompareMap(a, b, %s) }", typeName, valInfo.TestComparer),
		}
	}
	log.Printf("unhandled type in getTypeInfo: %T", expr)
	return typeGenInfo{}
}

// getSizeExpr recursively builds the Go expression string to calculate the marshalled size of a variable.
func (g *Generator) getSizeExpr(expr ast.Expr, varName string) string {
	typeName := g.exprToString(expr)
	// If the type is a custom struct or map alias, call its .Size() method.
	if ts, ok := g.typeSpecs[typeName]; ok {
		// For map aliases, we must prevent infinite recursion when generating the method body itself.
		// A simple heuristic is to check if the varName is the receiver of the method.
		if _, isMap := ts.Type.(*ast.MapType); isMap {
			receiverName := strings.ToLower(typeName[:1]) + typeName[1:]
			if varName == "*"+receiverName {
				// This is the method body for the alias itself, so fall through to generate the map logic directly.
			} else {
				return fmt.Sprintf("%s.Size()", varName)
			}
		} else {
			return fmt.Sprintf("%s.Size()", varName)
		}
	}
	if ident, ok := expr.(*ast.Ident); ok {
		if _, ok := g.typeSpecs[ident.Name]; ok {
			return fmt.Sprintf("%s.Size()", varName)
		}
	}

	switch t := expr.(type) {
	case *ast.Ident:
		info := g.getTypeInfo(t)
		sizer := "bstd.Size" + strings.Title(info.TypeName)
		if info.TypeName == "byte" {
			sizer = "bstd.SizeByte"
		}
		if info.TypeName == "rune" {
			sizer = "bstd.SizeInt32"
		}

		if info.IsFixedSize {
			return sizer + "()"
		}
		return fmt.Sprintf("%s(%s)", sizer, varName)

	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		// Special, efficient handling for []byte.
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("bstd.SizeBytes(%s)", varName)
		}
		// Recursively generate the sizer function for the element type.
		eltSizer := fmt.Sprintf("func(v %s) int { return %s }", eltInfo.TypeName, g.getSizeExpr(t.Elt, "v"))
		return fmt.Sprintf("bstd.SizeSlice(%s, %s)", varName, eltSizer)

	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		// Recursively generate sizers for key and value types.
		keySizer := fmt.Sprintf("func(k %s) int { return %s }", keyInfo.TypeName, g.getSizeExpr(t.Key, "k"))
		valSizer := fmt.Sprintf("func(v %s) int { return %s }", valInfo.TypeName, g.getSizeExpr(t.Value, "v"))
		return fmt.Sprintf("bstd.SizeMap(%s, %s, %s)", varName, keySizer, valSizer)

	default:
		log.Printf("unhandled type in getSizeExpr: %T", expr)
		return fmt.Sprintf("0 /* unhandled type %T */", expr)
	}
}

// getMarshalExpr recursively builds the Go expression string to marshal a variable.
func (g *Generator) getMarshalExpr(expr ast.Expr, n, buf, varName string) string {
	typeName := g.exprToString(expr)
	// If the type is a custom struct or map alias, call its .Marshal() method.
	if ts, ok := g.typeSpecs[typeName]; ok {
		if _, isMap := ts.Type.(*ast.MapType); isMap {
			receiverName := strings.ToLower(typeName[:1]) + typeName[1:]
			if varName == "*"+receiverName {
				// fallthrough
			} else {
				return fmt.Sprintf("%s.Marshal(%s, %s)", varName, n, buf)
			}
		} else {
			return fmt.Sprintf("%s.Marshal(%s, %s)", varName, n, buf)
		}
	}
	if ident, ok := expr.(*ast.Ident); ok {
		if _, ok := g.typeSpecs[ident.Name]; ok {
			return fmt.Sprintf("%s.Marshal(%s, %s)", varName, n, buf)
		}
	}

	info := g.getTypeInfo(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		return fmt.Sprintf("%s(%s, %s, %s)", info.Marshaler, n, buf, varName)

	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("bstd.MarshalBytes(%s, %s, %s)", n, buf, varName)
		}
		// Recursively generate the marshaler function for the element type.
		eltMarshaler := fmt.Sprintf("func(n int, b []byte, v %s) int { return %s }",
			eltInfo.TypeName, g.getMarshalExpr(t.Elt, "n", "b", "v"))
		return fmt.Sprintf("bstd.MarshalSlice(%s, %s, %s, %s)", n, buf, varName, eltMarshaler)

	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		// Recursively generate marshalers for key and value types.
		keyMarshaler := fmt.Sprintf("func(n int, b []byte, k %s) int { return %s }",
			keyInfo.TypeName, g.getMarshalExpr(t.Key, "n", "b", "k"))
		valMarshaler := fmt.Sprintf("func(n int, b []byte, v %s) int { return %s }",
			valInfo.TypeName, g.getMarshalExpr(t.Value, "n", "b", "v"))
		return fmt.Sprintf("bstd.MarshalMap(%s, %s, %s, %s, %s)", n, buf, varName, keyMarshaler, valMarshaler)

	default:
		log.Printf("unhandled type in getMarshalExpr: %T", expr)
		return n
	}
}

// getUnmarshalExpr recursively builds the Go expression string to unmarshal a variable.
func (g *Generator) getUnmarshalExpr(expr ast.Expr, n, buf, varName string) string {
	typeName := g.exprToString(expr)
	// If the type is a custom struct or map alias, call its .Unmarshal() method.
	if ts, ok := g.typeSpecs[typeName]; ok {
		if _, isMap := ts.Type.(*ast.MapType); isMap {
			receiverName := strings.ToLower(typeName[:1]) + typeName[1:]
			if varName == "*"+receiverName {
				// fallthrough
			} else {
				return fmt.Sprintf("n, err = %s.Unmarshal(%s, %s)", varName, n, buf)
			}
		} else {
			return fmt.Sprintf("n, err = %s.Unmarshal(%s, %s)", varName, n, buf)
		}
	}
	if ident, ok := expr.(*ast.Ident); ok {
		if _, ok := g.typeSpecs[ident.Name]; ok {
			return fmt.Sprintf("n, err = %s.Unmarshal(%s, %s)", varName, n, buf)
		}
	}

	info := g.getTypeInfo(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		return fmt.Sprintf("n, %s, err = %s(%s, %s)", varName, info.Unmarshaler, n, buf)

	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("n, %s, err = bstd.UnmarshalBytesCopied(%s, %s)", varName, n, buf)
		}
		// Generate the unmarshaler function for the element type.
		// Note the `(*v)` which is required because `UnmarshalSlice` passes a pointer to the element.
		eltUnmarshaler := fmt.Sprintf("func(n int, b []byte, v *%s) (int, error) { %s; return n, err }",
			eltInfo.TypeName, g.getUnmarshalExpr(t.Elt, "n", "b", "(*v)"))
		unmarshalCall := fmt.Sprintf("bstd.UnmarshalSlice[%s](%s, %s, %s)", eltInfo.TypeName, n, buf, eltUnmarshaler)
		return fmt.Sprintf("n, %s, err = %s", varName, unmarshalCall)

	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		// Generate unmarshaler lambdas for key and value types.
		keyUnmarshaler := fmt.Sprintf("func(n int, b []byte, k *%s) (int, error) { %s; return n, err }",
			keyInfo.TypeName, g.getUnmarshalExpr(t.Key, "n", "b", "(*k)"))
		valUnmarshaler := fmt.Sprintf("func(n int, b []byte, v *%s) (int, error) { %s; return n, err }",
			valInfo.TypeName, g.getUnmarshalExpr(t.Value, "n", "b", "(*v)"))
		unmarshalCall := fmt.Sprintf("bstd.UnmarshalMap[%s, %s](%s, %s, %s, %s)",
			keyInfo.TypeName, valInfo.TypeName, n, buf, keyUnmarshaler, valUnmarshaler)
		return fmt.Sprintf("n, %s, err = %s", varName, unmarshalCall)

	default:
		log.Printf("unhandled type in getUnmarshalExpr: %T", expr)
		return fmt.Sprintf("n, %s, err = %s(%s, %s)", varName, info.Unmarshaler, n, buf)
	}
}

// --- Test Generation ---

func (g *Generator) generateTestGenerator(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Generate%s(r *rand.Rand, depth int) %s {\n", name, name)
	g.printf("\tif depth <= 0 { return *new(%s) }\n", name)
	switch t := ts.Type.(type) {
	case *ast.StructType:
		g.printf("\treturn %s{\n", name)
		for _, field := range t.Fields.List {
			if g.isUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				gen := g.getTypeInfo(field.Type).TestGenerator
				// Handle lambda functions for generators of complex types (slices, maps).
				if strings.HasPrefix(gen, "func") {
					gen = fmt.Sprintf("(%s)(r, depth-1)", gen)
				} else {
					gen = fmt.Sprintf("%s(r, depth-1)", gen)
				}
				g.printf("\t\t%s: %s,\n", fName.Name, gen)
			}
		}
		g.printf("\t}\n")
	case *ast.MapType, *ast.ArrayType:
		if g.isUnsupportedType(ts.Type) {
			g.printf("\treturn nil\n") // Return nil/zero value for unsupported alias types
		} else {
			gen := g.getTypeInfo(ts.Type).TestGenerator
			// Wrap lambda for immediate execution.
			g.printf("\treturn (%s)(r, depth-1)\n", gen)
		}
	default:
		gen := g.getTypeInfo(ts.Type).TestGenerator
		g.printf("\treturn %s(r, depth-1)\n", gen)
	}
	g.printf("}\n\n")
}

func (g *Generator) generateTestComparer(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Compare%s(a, b %s) error {\n", name, name)
	switch t := ts.Type.(type) {
	case *ast.StructType:
		for _, field := range t.Fields.List {
			if g.isUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				comparer := g.getTypeInfo(field.Type).TestComparer
				g.printf("\tif err := btst.CompareField(\"%s\", func() error { return %s(a.%s, b.%s) }); err != nil {\n\t\treturn err\n\t}\n", fName.Name, comparer, fName.Name, fName.Name)
			}
		}
		g.printf("\treturn nil\n")
	default: // Handles map aliases and other types
		if g.isUnsupportedType(t) {
			g.printf("\treturn nil // Type is unsupported\n")
		} else {
			comparer := g.getTypeInfo(t).TestComparer
			g.printf("\treturn %s(a, b)\n", comparer)
		}
	}
	g.printf("}\n\n")
}

func (g *Generator) generateTestMain(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Test%s(t *testing.T) {\n", name)
	g.printf("\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n")
	g.printf("\toriginal := Generate%s(r, btst.MaxDepth)\n\n", name)
	g.printf("\ts := original.Size()\n")
	g.printf("\tbuf := make([]byte, s)\n")
	g.printf("\tn := original.Marshal(0, buf)\n\n")
	g.printf("\tif n != s {\n")
	g.printf("\t\tt.Fatalf(\"Marshal size mismatch: expected %%d, got %%d\", s, n)\n")
	g.printf("\t}\n\n")
	g.printf("\tvar copy %s\n", name)
	g.printf("\tbytesRead, err := copy.Unmarshal(0, buf)\n")
	g.printf("\tif err != nil {\n")
	g.printf("\t\tt.Fatalf(\"Unmarshal failed: %%v\", err)\n")
	g.printf("\t}\n")
	g.printf("\tif bytesRead != s {\n")
	g.printf("\t\tt.Fatalf(\"Unmarshal bytes read mismatch: expected %%d, got %%d\", s, bytesRead)\n")
	g.printf("\t}\n\n")
	g.printf("\tif err := Compare%s(original, copy); err != nil {\n", name)
	g.printf("\t\tt.Fatalf(\"Comparison failed: %%v\\nOriginal: %%#v\\nCopy: %%#v\", err, original, copy)\n")
	g.printf("\t}\n")
	g.printf("}\n\n")
}

// --- Utilities ---

func (g *Generator) exprToString(expr ast.Expr) string {
	var b bytes.Buffer
	if err := format.Node(&b, token.NewFileSet(), expr); err != nil {
		log.Printf("failed to convert expr to string: %v", err)
		return ""
	}
	return b.String()
}

func (g *Generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) format() (string, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// If formatting fails, return the unformatted source with the error for debugging.
		log.Printf("---BEGIN FAILED SOURCE---\n%s\n---END FAILED SOURCE---", g.buf.String())
		return "", fmt.Errorf("failed to format generated code: %w", err)
	}
	return string(src), nil
}

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run generator.go <input_file.go>")
	}
	inputFile := os.Args[1]
	outputDir := filepath.Dir(inputFile)

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFile, nil, 0)
	if err != nil {
		log.Fatalf("failed to parse input file %s: %v", inputFile, err)
	}

	types := collectTypes(node)
	if len(types) == 0 {
		log.Printf("no structs or map aliases found in %s", inputFile)
		return
	}

	pkgName := node.Name.Name
	generator := NewGenerator(pkgName)

	generatedCode, err := generator.Generate(types)
	if err != nil {
		log.Fatalf("failed to generate code: %v", err)
	}

	generatedTestCode, err := generator.GenerateTests(types)
	if err != nil {
		log.Fatalf("failed to generate test code: %v", err)
	}

	baseName := strings.TrimSuffix(filepath.Base(inputFile), ".go")
	outputFileName := filepath.Join(outputDir, fmt.Sprintf("%s_benc.go", baseName))
	outputTestFileName := filepath.Join(outputDir, fmt.Sprintf("%s_benc_test.go", baseName))

	if err := os.WriteFile(outputFileName, []byte(generatedCode), 0644); err != nil {
		log.Fatalf("failed to write generated code to file: %v", err)
	}
	log.Printf("Successfully generated %s", outputFileName)

	if err := os.WriteFile(outputTestFileName, []byte(generatedTestCode), 0644); err != nil {
		log.Fatalf("failed to write generated test code to file: %v", err)
	}
	log.Printf("Successfully generated %s", outputTestFileName)
}

// collectTypes gathers all type declarations for structs and map aliases.
func collectTypes(node *ast.File) []*ast.TypeSpec {
	var types []*ast.TypeSpec
	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true // Continue inspection
		}
		// We are interested in struct types and type aliases for map types.
		switch ts.Type.(type) {
		case *ast.StructType, *ast.MapType:
			types = append(types, ts)
		}
		return false // Do not inspect inside the type spec
	})
	return types
}
