package codegens

import (
	"fmt"
	"os"
	"slices"
	"strings"

	"go.kine.bz/benc/cmd/bencgen/parser"
)

type GeneratorLanguage string

const (
	GenGolang GeneratorLanguage = "go"
)

func (lang GeneratorLanguage) String() string {
	switch lang {
	case GenGolang:
		return "golang"
	}
	return "invalid"
}

func toUpper(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func toLower(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}

type Generator interface {
	File() string
	Lang() GeneratorLanguage
	GenHeader(containsMaxSize bool, stmt *parser.HeaderStmt) string
	/* GenerateHeaderEnd() string */
	GenStruct(ctrDeclarations []string, stmt *parser.CtrStmt) string
	GenReservedIds(stmt *parser.CtrStmt) string
	GenSize(stmt *parser.CtrStmt) string
	GenMarshal(stmt *parser.CtrStmt) string
	GenUnmarshal(stmt *parser.CtrStmt) string
	GenNestedUnmarshal(stmt *parser.CtrStmt) string
}

func NewGenerator(lang GeneratorLanguage, file string) Generator {
	switch lang {
	case GenGolang:
		return GoGenerator{
			file:      file,
			generated: "",
		}
	}
	return nil
}

func createError(g Generator, m string) {
	errorMessage := "\n\033[1;31m[bencgen] Error:\033[0m\n"
	errorMessage += fmt.Sprintf("    \033[1;37mFile:\033[0m %s\n", g.File())
	errorMessage += fmt.Sprintf("    \033[1;37mMessage:\033[0m %s\n", m)
	errorMessage += fmt.Sprintf("    \033[1;37mLanguage:\033[0m %s\n", g.Lang().String())
	fmt.Println(errorMessage)
	os.Exit(-1)
}

var unallowedNames = []string{"b", "n", "id", "r"}

func Generate(gen Generator, nodes []parser.Node) string {
	containsHeader := false
	ctrDeclarations := []string{}

	res := fmt.Sprintf("// Code generated by bencgen %s. DO NOT EDIT.\n// source: %s\n\n", gen.Lang().String(), gen.File())

	containsMaxSize := false
	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.CtrStmt:
			if slices.Contains(ctrDeclarations, stmt.Name) {
				createError(gen, "Multiple containers with the same name \"%s\"."+stmt.Name)
			}
			ctrDeclarations = append(ctrDeclarations, stmt.Name)

			if len(stmt.Fields) == 0 {
				createError(gen, "Empty container \"%s\"."+stmt.Name)
			}

			for _, field := range stmt.Fields {
				if field.MaxSize > 0 {
					containsMaxSize = true
				}
			}
		}
	}

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.HeaderStmt:
			if containsHeader {
				createError(gen, "Multiple `header` declarations.")
			}

			res += gen.GenHeader(containsMaxSize, stmt)
			containsHeader = true
		case *parser.CtrStmt:
			if !containsHeader {
				createError(gen, "A `header` was not declared.")
			}

			var ids []uint16
			var lId uint16

			private := toLower(stmt.Name)

			if slices.Contains(unallowedNames, private) {
				createError(gen, fmt.Sprintf("Unallowed container name \"%s\".", stmt.Name))
			}

			var fieldNames []string
			for _, field := range stmt.Fields {
				if field.Id == 0 {
					createError(gen, fmt.Sprintf("Field \"%s\" has an ID of \"0\" on \"%s\".", field.Name, stmt.Name))
				}

				if slices.Contains(ids, field.Id) {
					createError(gen, fmt.Sprintf("Multiple fields with the same ID \"%d\" on \"%s\".", field.Id, stmt.Name))
				}

				if lId > field.Id {
					createError(gen, fmt.Sprintf("Fields must be ordered by their IDs in ascending order on \"%s\".", stmt.Name))
				}

				if slices.Contains(fieldNames, field.Name) {
					createError(gen, fmt.Sprintf("Multiple fields with the same name \"%s\" on \"%s\".", field.Name, stmt.Name))
				}

				lId = field.Id
				ids = append(ids, field.Id)
				fieldNames = append(fieldNames, field.Name)
			}

			res += gen.GenStruct(ctrDeclarations, stmt)
			res += gen.GenReservedIds(stmt)
			res += gen.GenSize(stmt)
			res += gen.GenMarshal(stmt)
			res += gen.GenNestedUnmarshal(stmt)
			res += gen.GenUnmarshal(stmt)
		}
	}

	return res
}
