package codegens

import (
	"fmt"
	"os"
	"slices"

	"github.com/deneonet/benc/cmd/bencgen/parser"
	"github.com/deneonet/benc/cmd/bencgen/utils"
)

type GenLang string

const (
	GoGenLang GenLang = "go"
)

func (lang GenLang) String() string {
	switch lang {
	case GoGenLang:
		return "go"
	default:
		return "invalid"
	}
}

type Gen interface {
	File() string
	Lang() GenLang

	GenHeader() string
	GenEnum() string
	GenStruct() string
	GenReservedIds() string
	GenSize() string
	GenMarshal() string
	GenUnmarshal() string
	GenSizePlain() string
	GenMarshalPlain() string
	GenUnmarshalPlain() string

	HasHeader() bool

	SetCtrDecls(ctrDecls []string)
	SetEnumDecls(ctrDecls []string)

	SetCtrStatement(stmt *parser.CtrStmt)
	SetEnumStatement(stmt *parser.EnumStmt)
	SetHeaderStatement(stmt *parser.HeaderStmt)
}

func NewGen(lang GenLang, file string) Gen {
	switch lang {
	case GoGenLang:
		return NewGoGen(file)
	default:
		return nil
	}
}

func logErrorAndExit(g Gen, msg string) {
	fmt.Printf("\n\033[1;31m[bencgen] Error:\033[0m\n"+
		"    \033[1;37mFile:\033[0m %s\n"+
		"    \033[1;37mMessage:\033[0m %s\n", g.File(), msg)
	os.Exit(1)
}

var disallowedNames = []string{"b", "n", "id", "r"}

func Generate(g Gen, nodes []parser.Node) string {
	ctrDecls := []string{}
	enumDecls := []string{}

	res := fmt.Sprintf("// Code generated by bencgen %s. DO NOT EDIT.\n// source: %s\n\n",
		g.Lang().String(), g.File())

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.CtrStmt:
			validateCtrStmt(g, stmt, enumDecls, ctrDecls)
			ctrDecls = append(ctrDecls, stmt.Name)
		case *parser.EnumStmt:
			validateEnumStmt(g, stmt, enumDecls, ctrDecls)
			enumDecls = append(enumDecls, stmt.Name)
		}
	}

	g.SetCtrDecls(ctrDecls)
	g.SetEnumDecls(enumDecls)

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.HeaderStmt:
			if g.HasHeader() {
				logErrorAndExit(g, "Multiple 'header' declarations.")
			}

			g.SetHeaderStatement(stmt)
			res += g.GenHeader()
		case *parser.CtrStmt:
			if !g.HasHeader() {
				logErrorAndExit(g, "A 'header' was not declared.")
			}
			validateContainerFields(g, stmt, ctrDecls, enumDecls)

			g.SetCtrStatement(stmt)
			res += generateCtr(g)
		case *parser.EnumStmt:
			if !g.HasHeader() {
				logErrorAndExit(g, "A 'header' was not declared.")
			}
			validateEnumFields(g, stmt)

			g.SetEnumStatement(stmt)
			res += g.GenEnum()
		}
	}

	return res
}

func validateCtrStmt(g Gen, stmt *parser.CtrStmt, enumDecls []string, ctrDecls []string) {
	if slices.Contains(enumDecls, stmt.Name) {
		logErrorAndExit(g, fmt.Sprintf("A enum with the same name \"%s\" is already declared.", stmt.Name))
	}

	if slices.Contains(ctrDecls, stmt.Name) {
		logErrorAndExit(g, fmt.Sprintf("Multiple containers with the same name \"%s\".", stmt.Name))
	}

	if len(stmt.Fields) == 0 {
		logErrorAndExit(g, fmt.Sprintf("Empty container \"%s\".", stmt.Name))
	}
}

func validateEnumStmt(g Gen, stmt *parser.EnumStmt, enumDecls []string, ctrDecls []string) {
	if slices.Contains(enumDecls, stmt.Name) {
		logErrorAndExit(g, fmt.Sprintf("Multiple enums with the same name \"%s\".", stmt.Name))
	}

	if slices.Contains(ctrDecls, stmt.Name) {
		logErrorAndExit(g, fmt.Sprintf("A container with the same name \"%s\" is already declared.", stmt.Name))
	}

	if len(stmt.Fields) == 0 {
		logErrorAndExit(g, fmt.Sprintf("Empty enum \"%s\".", stmt.Name))
	}
}

func validateContainerFields(g Gen, stmt *parser.CtrStmt, ctrDecls []string, enumDecls []string) {
	var ids []uint16
	var lastID uint16
	var fieldNames []string

	for _, field := range stmt.Fields {
		_, enumNotFound := utils.FindUndeclaredContainersOrEnums(enumDecls, field.Type)
		if ctrEnum, notFound := utils.FindUndeclaredContainersOrEnums(ctrDecls, field.Type); notFound && enumNotFound {
			logErrorAndExit(g, fmt.Sprintf("Container/Enum \"%s\" not declared on \"%s\" (\"%s\").", ctrEnum, stmt.Name, field.Name))
		}

		if field.Id == 0 {
			logErrorAndExit(g, fmt.Sprintf("Field \"%s\" has an ID of \"0\" on \"%s\".", field.Name, stmt.Name))
		}

		if slices.Contains(ids, field.Id) {
			logErrorAndExit(g, fmt.Sprintf("Multiple fields with the same ID \"%d\" on \"%s\".", field.Id, stmt.Name))
		}

		if lastID > field.Id {
			logErrorAndExit(g, fmt.Sprintf("Fields must be ordered by their IDs in ascending order on \"%s\".", stmt.Name))
		}

		if slices.Contains(fieldNames, field.Name) {
			logErrorAndExit(g, fmt.Sprintf("Multiple fields with the same name \"%s\" on \"%s\".", field.Name, stmt.Name))
		}

		if slices.Contains(disallowedNames, utils.ToLower(stmt.Name)) {
			logErrorAndExit(g, fmt.Sprintf("Unallowed container name \"%s\".", stmt.Name))
		}

		lastID = field.Id
		ids = append(ids, field.Id)
		fieldNames = append(fieldNames, field.Name)
	}
}

func validateEnumFields(g Gen, stmt *parser.EnumStmt) {
	var fieldNames []string

	for _, field := range stmt.Fields {
		if slices.Contains(fieldNames, field) {
			logErrorAndExit(g, fmt.Sprintf("Multiple fields with the same name \"%s\" on \"%s\".", field, stmt.Name))
		}
		fieldNames = append(fieldNames, field)
	}
}

func generateCtr(g Gen) string {
	return g.GenStruct() +
		g.GenReservedIds() +
		g.GenSize() +
		g.GenSizePlain() +
		g.GenMarshal() +
		g.GenMarshalPlain() +
		g.GenUnmarshal() +
		g.GenUnmarshalPlain()
}
