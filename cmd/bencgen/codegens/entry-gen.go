package codegens

import (
	"fmt"
	"os"
	"slices"

	"github.com/deneonet/benc/cmd/bencgen/parser"
	"github.com/deneonet/benc/cmd/bencgen/utils"
)

type GeneratorLanguage string

const (
	GenGolang GeneratorLanguage = "go"
)

func (lang GeneratorLanguage) String() string {
	switch lang {
	case GenGolang:
		return "golang"
	default:
		return "invalid"
	}
}

type Generator interface {
	File() string
	Lang() GeneratorLanguage
	GenHeader(stmt *parser.HeaderStmt) string
	GenStruct(ctrDeclarations []string, stmt *parser.CtrStmt) string
	GenReservedIds(stmt *parser.CtrStmt) string
	GenSize(stmt *parser.CtrStmt) string
	GenMarshal(stmt *parser.CtrStmt) string
	GenUnmarshal(stmt *parser.CtrStmt) string
	GenSizePlain(stmt *parser.CtrStmt) string
	GenMarshalPlain(stmt *parser.CtrStmt) string
	GenUnmarshalPlain(stmt *parser.CtrStmt) string
}

func NewGenerator(lang GeneratorLanguage, file string) Generator {
	switch lang {
	case GenGolang:
		return NewGoGenerator(file)
	default:
		return nil
	}
}

func logErrorAndExit(g Generator, msg string) {
	fmt.Printf("\n\033[1;31m[bencgen] Error:\033[0m\n"+
		"    \033[1;37mFile:\033[0m %s\n"+
		"    \033[1;37mMessage:\033[0m %s\n", g.File(), msg)
	os.Exit(1)
}

var unallowedNames = []string{"b", "n", "id", "r"}

func Generate(gen Generator, nodes []parser.Node) string {
	containsHeader := false
	ctrDeclarations := []string{}

	res := fmt.Sprintf("// Code generated by bencgen %s. DO NOT EDIT.\n// source: %s\n\n", gen.Lang().String(), gen.File())
	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.CtrStmt:
			validateCtrStmt(gen, stmt, ctrDeclarations)
			ctrDeclarations = append(ctrDeclarations, stmt.Name)
		}
	}

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.HeaderStmt:
			if containsHeader {
				logErrorAndExit(gen, "Multiple `header` declarations.")
			}
			res += gen.GenHeader(stmt)
			containsHeader = true
		case *parser.CtrStmt:
			if !containsHeader {
				logErrorAndExit(gen, "A `header` was not declared.")
			}
			validateContainerFields(gen, stmt, ctrDeclarations)
			res += generateContainerCode(gen, stmt, ctrDeclarations)
		}
	}

	return res
}

func validateCtrStmt(gen Generator, stmt *parser.CtrStmt, ctrDeclarations []string) {
	if slices.Contains(ctrDeclarations, stmt.Name) {
		logErrorAndExit(gen, fmt.Sprintf("Multiple containers with the same name \"%s\".", stmt.Name))
	}
	if len(stmt.Fields) == 0 {
		logErrorAndExit(gen, fmt.Sprintf("Empty container \"%s\".", stmt.Name))
	}
}

func validateContainerFields(gen Generator, stmt *parser.CtrStmt, ctrDeclarations []string) {
	var ids []uint16
	var lastID uint16
	var fieldNames []string

	for _, field := range stmt.Fields {
		if ctr, found := utils.FindUndeclaredContainers(ctrDeclarations, field.Type); found {
			logErrorAndExit(gen, fmt.Sprintf("Container \"%s\" not declared on \"%s\" (\"%s\").", ctr, stmt.Name, field.Name))
		}

		if field.Id == 0 {
			logErrorAndExit(gen, fmt.Sprintf("Field \"%s\" has an ID of \"0\" on \"%s\".", field.Name, stmt.Name))
		}

		if slices.Contains(ids, field.Id) {
			logErrorAndExit(gen, fmt.Sprintf("Multiple fields with the same ID \"%d\" on \"%s\".", field.Id, stmt.Name))
		}

		if lastID > field.Id {
			logErrorAndExit(gen, fmt.Sprintf("Fields must be ordered by their IDs in ascending order on \"%s\".", stmt.Name))
		}

		if slices.Contains(fieldNames, field.Name) {
			logErrorAndExit(gen, fmt.Sprintf("Multiple fields with the same name \"%s\" on \"%s\".", field.Name, stmt.Name))
		}

		if slices.Contains(unallowedNames, utils.ToLower(stmt.Name)) {
			logErrorAndExit(gen, fmt.Sprintf("Unallowed container name \"%s\".", stmt.Name))
		}

		lastID = field.Id
		ids = append(ids, field.Id)
		fieldNames = append(fieldNames, field.Name)
	}
}

func generateContainerCode(gen Generator, stmt *parser.CtrStmt, ctrDeclarations []string) string {
	return gen.GenStruct(ctrDeclarations, stmt) +
		gen.GenReservedIds(stmt) +
		gen.GenSize(stmt) +
		gen.GenSizePlain(stmt) +
		gen.GenMarshal(stmt) +
		gen.GenMarshalPlain(stmt) +
		gen.GenUnmarshal(stmt) +
		gen.GenUnmarshalPlain(stmt)
}
