package codegens

import (
	"fmt"
	"os"
	"slices"

	"github.com/deneonet/benc/cmd/bencgen/parser"
	"github.com/deneonet/benc/cmd/bencgen/utils"
)

type GenLang string

const (
	GoGenLang GenLang = "go"
)

func (lang GenLang) String() string {
	switch lang {
	case GoGenLang:
		return "go"
	default:
		return "invalid"
	}
}

type Gen interface {
	File() string
	Lang() GenLang

	GenDefine() string
	GenEnum() string
	GenStruct() string
	GenReservedIds() string
	GenSize() string
	GenMarshal() string
	GenUnmarshal() string
	GenSizePlain() string
	GenMarshalPlain() string
	GenUnmarshalPlain() string

	ProcessImport(stmt *parser.UseStmt, importDirs []string) ([]string, []string)

	SetVarMap(map[string]string)

	HasPackageDefined() bool

	AddEnumDecls(enumDecls []string)
	AddContainerDecls(containerDecls []string)

	SetEnumStatement(stmt *parser.EnumStmt)
	SetDefineStatement(stmt *parser.DefineStmt)
	SetContainerStatement(stmt *parser.ContainerStmt)
}

func NewGen(lang GenLang, file string) Gen {
	switch lang {
	case GoGenLang:
		return NewGoGen(file)
	default:
		return nil
	}
}

func LogErrorAndExit(g Gen, msg string) {
	fmt.Printf("\n\033[1;31m[bencgen] Error:\033[0m\n"+
		"    \033[1;37mFile:\033[0m %s\n"+
		"    \033[1;37mMessage:\033[0m %s\n", g.File(), msg)
	os.Exit(1)
}

var disallowedNames = []string{"b", "n", "id", "r"}

func Generate(g Gen, nodes []parser.Node, importDirs []string) string {
	enumDecls := []string{}
	containerDecls := []string{}

	varMap := make(map[string]string)

	res := fmt.Sprintf("// Code generated by bencgen %s. DO NOT EDIT.\n// source: %s\n\n",
		g.Lang().String(), g.File())

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.UseStmt:
			aEnumDecls, aContainerDecls := g.ProcessImport(stmt, importDirs)
			enumDecls = append(enumDecls, aEnumDecls...)
			containerDecls = append(containerDecls, aContainerDecls...)
		}
	}

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.EnumStmt:
			validateEnumStmt(g, stmt, enumDecls, containerDecls)
			enumDecls = append(enumDecls, stmt.Name)
		case *parser.ContainerStmt:
			validateCtrStmt(g, stmt, enumDecls, containerDecls)
			containerDecls = append(containerDecls, stmt.Name)
		case *parser.VarStmt:
			varMap[stmt.Name] = stmt.Value
		}
	}

	g.AddEnumDecls(enumDecls)
	g.AddContainerDecls(containerDecls)

	g.SetVarMap(varMap)

	for _, node := range nodes {
		switch stmt := node.(type) {
		case *parser.DefineStmt:
			if g.HasPackageDefined() {
				LogErrorAndExit(g, "Multiple packages defined ( 'define ...' ).")
			}

			g.SetDefineStatement(stmt)
			res += g.GenDefine()
		case *parser.EnumStmt:
			if !g.HasPackageDefined() {
				LogErrorAndExit(g, "A package was not defined ( 'define ...' ).")
			}
			validateEnumFields(g, stmt)

			g.SetEnumStatement(stmt)
			res += g.GenEnum()
		case *parser.ContainerStmt:
			if !g.HasPackageDefined() {
				LogErrorAndExit(g, "A package was not defined ( 'define ...' ).")
			}
			validateContainerFields(g, stmt, containerDecls, enumDecls)

			g.SetContainerStatement(stmt)
			res += generateContainer(g)
		}
	}

	return res
}

func validateCtrStmt(g Gen, stmt *parser.ContainerStmt, enumDecls []string, containerDecls []string) {
	if slices.Contains(enumDecls, stmt.Name) {
		LogErrorAndExit(g, fmt.Sprintf("A enum with the same name '%s' is already declared.", stmt.Name))
	}

	if slices.Contains(containerDecls, stmt.Name) {
		LogErrorAndExit(g, fmt.Sprintf("Multiple containers with the same name '%s'.", stmt.Name))
	}

	if len(stmt.Fields) == 0 {
		LogErrorAndExit(g, fmt.Sprintf("Empty container '%s'.", stmt.Name))
	}
}

func validateEnumStmt(g Gen, stmt *parser.EnumStmt, enumDecls []string, containerDecls []string) {
	if slices.Contains(enumDecls, stmt.Name) {
		LogErrorAndExit(g, fmt.Sprintf("Multiple enums with the same name '%s'.", stmt.Name))
	}

	if slices.Contains(containerDecls, stmt.Name) {
		LogErrorAndExit(g, fmt.Sprintf("A container with the same name '%s' is already declared.", stmt.Name))
	}

	if slices.Contains(disallowedNames, utils.ToLower(stmt.Name)) {
		LogErrorAndExit(g, fmt.Sprintf("Disallowed enum name '%s'.", stmt.Name))
	}

	if len(stmt.Values) == 0 {
		LogErrorAndExit(g, fmt.Sprintf("Empty enum '%s'.", stmt.Name))
	}
}

func validateContainerFields(g Gen, stmt *parser.ContainerStmt, enumDecls []string, containerDecls []string) {
	var ids []uint16
	var lastID uint16
	var fieldNames []string

	for _, field := range stmt.Fields {
		_, enumNotFound := utils.FindUndeclaredContainersOrEnums(enumDecls, field.Type)
		if ctrEnum, notFound := utils.FindUndeclaredContainersOrEnums(containerDecls, field.Type); notFound && enumNotFound {
			LogErrorAndExit(g, fmt.Sprintf("Container/Enum '%s' not declared on '%s' ('%s').", ctrEnum, stmt.Name, field.Name))
		}

		if field.ID == 0 {
			LogErrorAndExit(g, fmt.Sprintf("Field '%s' has an ID of '0' on '%s'.", field.Name, stmt.Name))
		}

		if slices.Contains(ids, field.ID) {
			LogErrorAndExit(g, fmt.Sprintf("Multiple fields with the same ID '%d' on '%s'.", field.ID, stmt.Name))
		}

		if lastID > field.ID {
			LogErrorAndExit(g, fmt.Sprintf("Fields must be ordered by their IDs in ascending order on '%s'.", stmt.Name))
		}

		if slices.Contains(fieldNames, field.Name) {
			LogErrorAndExit(g, fmt.Sprintf("Multiple fields with the same name '%s' on '%s'.", field.Name, stmt.Name))
		}

		if slices.Contains(disallowedNames, utils.ToLower(stmt.Name)) {
			LogErrorAndExit(g, fmt.Sprintf("Disallowed container name '%s'.", stmt.Name))
		}

		lastID = field.ID
		ids = append(ids, field.ID)
		fieldNames = append(fieldNames, field.Name)
	}
}

func validateEnumFields(g Gen, stmt *parser.EnumStmt) {
	var fieldNames []string

	for _, field := range stmt.Values {
		if slices.Contains(fieldNames, field) {
			LogErrorAndExit(g, fmt.Sprintf("Multiple values '%s' on '%s'.", field, stmt.Name))
		}
		fieldNames = append(fieldNames, field)
	}
}

func generateContainer(g Gen) string {
	return g.GenStruct() +
		g.GenReservedIds() +
		g.GenSize() +
		g.GenSizePlain() +
		g.GenMarshal() +
		g.GenMarshalPlain() +
		g.GenUnmarshal() +
		g.GenUnmarshalPlain()
}
