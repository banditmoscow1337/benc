package golang

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"log"
	"strings"

	"github.com/banditmoscow1337/benc/cmd/internal/common"
)

type generator struct {
	*common.Context
	buf bytes.Buffer
}

func New(ctx *common.Context) common.Generator {
	return &generator{Context: ctx}
}

func (g *generator) Generate() (err error) {
	g.printf("// Code generated by benc generator; DO NOT EDIT.\n\n")
	g.printf("package %s\n\n", g.PkgName)
	g.printf("import (\n")
	g.printf("\tbstd \"github.com/banditmoscow1337/benc/std/golang\"\n")
	g.printf(")\n\n")

	for _, ts := range g.Types {
		if err = g.generateGoMethods(ts); err != nil {
			err = fmt.Errorf("generating methods for %s: %w", ts.Name.Name, err)
			return
		}
	}

	res, _ := g.formatGo()

	common.WriteFile(g.Context, []byte(res), "go")

	g.buf.Reset()

	return 
}

func (g *generator) generateGoMethods(ts *ast.TypeSpec) error {
	switch ts.Type.(type) {
	case *ast.StructType:
		return g.generateGoStructMethods(ts)
	case *ast.MapType:
		return g.generateGoMapAliasMethods(ts)
	}
	return nil
}

func (g *generator) generateGoStructMethods(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	receiver := strings.ToLower(name[:1]) + name[1:]
	supportedFields := g.GetSupportedFields(ts)

	// Size Method
	g.printf("func (%s *%s) Size() (s int) {\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\ts += %s\n", g.getGoSizeExpr(field.Type, fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn\n}\n\n")

	// Marshal Method
	g.printf("func (%s *%s) Marshal(tn int, b []byte) (n int) {\n\tn = tn\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\tn = %s\n", g.getGoMarshalExpr(field.Type, "n", "b", fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn n\n}\n\n")

	// Unmarshal Method
	g.printf("func (%s *%s) Unmarshal(tn int, b []byte) (n int, err error) {\n\tn = tn\n", receiver, name)
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\tif %s; err != nil {\n\t\treturn\n\t}\n", g.getGoUnmarshalExpr(field.Type, "n", "b", fmt.Sprintf("%s.%s", receiver, fName.Name)))
		}
	}
	g.printf("\treturn\n}\n\n")
	return nil
}

func (g *generator) generateGoMapAliasMethods(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	receiver := strings.ToLower(name[:1]) + name[1:]
	mapType := ts.Type.(*ast.MapType)

	if g.IsUnsupportedType(mapType) {
		return nil
	}

	g.printf("func (%s *%s) Size() (s int) {\n", receiver, name)
	g.printf("\ts += %s\n", g.getGoSizeExpr(mapType, "*"+receiver))
	g.printf("\treturn\n}\n\n")

	g.printf("func (%s *%s) Marshal(tn int, b []byte) (n int) {\n\tn = tn\n", receiver, name)
	g.printf("\tn = %s\n", g.getGoMarshalExpr(mapType, "n", "b", "*"+receiver))
	g.printf("\treturn\n}\n\n")

	g.printf("func (%s *%s) Unmarshal(tn int, b []byte) (n int, err error) {\n\tn = tn\n", receiver, name)
	g.printf("\tif %s; err != nil {\n\t\treturn\n\t}\n", g.getGoUnmarshalExpr(mapType, "n", "b", "*"+receiver))
	g.printf("\treturn\n}\n\n")
	return nil
}

// -----------------------------------------------------------------------------
// GO TEST GENERATION
// -----------------------------------------------------------------------------

func (g *generator) Tests() {
	g.printf("// Code generated by benc generator; DO NOT EDIT.\n\n")
	g.printf("package %s\n\n", g.PkgName)
	g.printf("import (\n")
	g.printf("\t\"math/rand\"\n")
	g.printf("\t\"testing\"\n")
	g.printf("\t\"time\"\n\n")
	g.printf("\tbtst \"github.com/banditmoscow1337/benc/std/golang\"\n")
	g.printf(")\n\n")

	for _, ts := range g.Types {
		g.generateGoTestGenerator(ts)
		g.generateGoTestComparer(ts)
	}

	var topLevelStruct *ast.TypeSpec
	for _, ts := range g.Types {
		if _, ok := ts.Type.(*ast.StructType); ok {
			if topLevelStruct == nil {
				topLevelStruct = ts
			}
		}
	}
	if topLevelStruct != nil {
		g.generateGoTestMain(topLevelStruct)
	}

	res, _  := g.formatGo()

	g.buf.Reset()

	common.WriteFile(g.Context, []byte(res), "test.go")
}

func (g *generator) generateGoTestGenerator(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Generate%s(r *rand.Rand, depth int) %s {\n", name, name)
	g.printf("\tif depth <= 0 { return *new(%s) }\n", name)
	switch t := ts.Type.(type) {
	case *ast.StructType:
		g.printf("\treturn %s{\n", name)
		for _, field := range t.Fields.List {
			if g.ShouldIgnoreField(field) || g.IsUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				gen := g.getTypeInfo(field.Type).TestGenerator
				if strings.HasPrefix(gen, "func") {
					gen = fmt.Sprintf("(%s)(r, depth-1)", gen)
				} else {
					gen = fmt.Sprintf("%s(r, depth-1)", gen)
				}
				g.printf("\t\t%s: %s,\n", fName.Name, gen)
			}
		}
		g.printf("\t}\n")
	case *ast.MapType, *ast.ArrayType:
		if g.IsUnsupportedType(ts.Type) {
			g.printf("\treturn nil\n")
		} else {
			gen := g.getTypeInfo(ts.Type).TestGenerator
			g.printf("\treturn (%s)(r, depth-1)\n", gen)
		}
	default:
		gen := g.getTypeInfo(ts.Type).TestGenerator
		g.printf("\treturn %s(r, depth-1)\n", gen)
	}
	g.printf("}\n\n")
}

func (g *generator) generateGoTestComparer(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Compare%s(a, b %s) error {\n", name, name)
	switch t := ts.Type.(type) {
	case *ast.StructType:
		for _, field := range t.Fields.List {
			if g.ShouldIgnoreField(field) || g.IsUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				comparer := g.getTypeInfo(field.Type).TestComparer
				g.printf("\tif err := btst.CompareField(\"%s\", func() error { return %s(a.%s, b.%s) }); err != nil {\n\t\treturn err\n\t}\n", fName.Name, comparer, fName.Name, fName.Name)
			}
		}
		g.printf("\treturn nil\n")
	default:
		if g.IsUnsupportedType(t) {
			g.printf("\treturn nil\n")
		} else {
			comparer := g.getTypeInfo(t).TestComparer
			g.printf("\treturn %s(a, b)\n", comparer)
		}
	}
	g.printf("}\n\n")
}

func (g *generator) generateGoTestMain(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("func Test%s(t *testing.T) {\n", name)
	g.printf("\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n")
	g.printf("\toriginal := Generate%s(r, btst.MaxDepth)\n\n", name)
	g.printf("\ts := original.Size()\n")
	g.printf("\tbuf := make([]byte, s)\n")
	g.printf("\tn := original.Marshal(0, buf)\n\n")
	g.printf("\tif n != s {\n")
	g.printf("\t\tt.Fatalf(\"Marshal size mismatch: expected %%d, got %%d\", s, n)\n")
	g.printf("\t}\n\n")
	g.printf("\tvar copy %s\n", name)
	g.printf("\tbytesRead, err := copy.Unmarshal(0, buf)\n")
	g.printf("\tif err != nil {\n")
	g.printf("\t\tt.Fatalf(\"Unmarshal failed: %%v\", err)\n")
	g.printf("\t}\n")
	g.printf("\tif bytesRead != s {\n")
	g.printf("\t\tt.Fatalf(\"Unmarshal bytes read mismatch: expected %%d, got %%d\", s, bytesRead)\n")
	g.printf("\t}\n\n")
	g.printf("\tif err := Compare%s(original, copy); err != nil {\n", name)
	g.printf("\t\tt.Fatalf(\"Comparison failed: %%v\\nOriginal: %%#v\\nCopy: %%#v\", err, original, copy)\n")
	g.printf("\t}\n")
	g.printf("}\n\n")
}

// -----------------------------------------------------------------------------
// HELPER METHODS (Private to this package)
// -----------------------------------------------------------------------------

func (g *generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *generator) formatGo() (string, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("---BEGIN FAILED SOURCE---\n%s\n---END FAILED SOURCE---", g.buf.String())
		return "", fmt.Errorf("failed to format generated code: %w", err)
	}
	return string(src), nil
}

// Go Expression Logic

func (g *generator) getGoSizeExpr(expr ast.Expr, varName string) string {
	typeName := g.ExprToString(expr)

	if ts, ok := g.TypeSpecs[typeName]; ok {
		if _, isMap := ts.Type.(*ast.MapType); isMap {
			receiverName := strings.ToLower(typeName[:1]) + typeName[1:]
			if varName != "*"+receiverName {
				return fmt.Sprintf("%s.Size()", varName)
			}
		} else {
			return fmt.Sprintf("%s.Size()", varName)
		}
	}
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s.Size()", varName)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		info := g.getTypeInfo(t)
		sizer := "bstd.Size" + strings.Title(info.TypeName)
		if info.TypeName == "byte" {
			sizer = "bstd.SizeByte"
		} else if info.TypeName == "rune" {
			sizer = "bstd.SizeInt32"
		}
		if info.IsFixedSize {
			return sizer + "()"
		}
		return fmt.Sprintf("%s(%s)", sizer, varName)
	case *ast.StarExpr:
		eltSizer := fmt.Sprintf("func(v %s) int { return %s }", g.ExprToString(t.X), g.getGoSizeExpr(t.X, "v"))
		return fmt.Sprintf("bstd.SizePointer(%s, %s)", varName, eltSizer)
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return "bstd.SizeTime()"
		}
		return fmt.Sprintf("%s.Size()", varName)
	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("bstd.SizeBytes(%s)", varName)
		}
		eltSizer := fmt.Sprintf("func(v %s) int { return %s }", eltInfo.TypeName, g.getGoSizeExpr(t.Elt, "v"))
		return fmt.Sprintf("bstd.SizeSlice(%s, %s)", varName, eltSizer)
	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		keySizer := fmt.Sprintf("func(k %s) int { return %s }", keyInfo.TypeName, g.getGoSizeExpr(t.Key, "k"))
		valSizer := fmt.Sprintf("func(v %s) int { return %s }", valInfo.TypeName, g.getGoSizeExpr(t.Value, "v"))
		return fmt.Sprintf("bstd.SizeMap(%s, %s, %s)", varName, keySizer, valSizer)
	default:
		return "0"
	}
}

func (g *generator) getGoMarshalExpr(expr ast.Expr, n, buf, varName string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s.Marshal(%s, %s)", varName, n, buf)
	}
	info := g.getTypeInfo(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		return fmt.Sprintf("%s(%s, %s, %s)", info.Marshaler, n, buf, varName)
	case *ast.StarExpr:
		eltType := g.ExprToString(t.X)
		eltMarshalFn := fmt.Sprintf("func(n int, b []byte, v %s) int { return %s }", eltType, g.getGoMarshalExpr(t.X, "n", "b", "v"))
		return fmt.Sprintf("bstd.MarshalPointer(%s, %s, %s, %s)", n, buf, varName, eltMarshalFn)
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("bstd.MarshalTime(%s, %s, %s)", n, buf, varName)
		}
		return fmt.Sprintf("%s.Marshal(%s, %s)", varName, n, buf)
	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("bstd.MarshalBytes(%s, %s, %s)", n, buf, varName)
		}
		eltMarshaler := fmt.Sprintf("func(n int, b []byte, v %s) int { return %s }", eltInfo.TypeName, g.getGoMarshalExpr(t.Elt, "n", "b", "v"))
		return fmt.Sprintf("bstd.MarshalSlice(%s, %s, %s, %s)", n, buf, varName, eltMarshaler)
	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		keyMarshal := fmt.Sprintf("func(n int, b []byte, k %s) int { return %s }", keyInfo.TypeName, g.getGoMarshalExpr(t.Key, "n", "b", "k"))
		valMarshal := fmt.Sprintf("func(n int, b []byte, v %s) int { return %s }", valInfo.TypeName, g.getGoMarshalExpr(t.Value, "n", "b", "v"))
		return fmt.Sprintf("bstd.MarshalMap(%s, %s, %s, %s, %s)", n, buf, varName, keyMarshal, valMarshal)
	default:
		return n
	}
}

func (g *generator) getGoUnmarshalExpr(expr ast.Expr, n, buf, varName string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("n, err = %s.Unmarshal(%s, %s)", varName, n, buf)
	}
	info := g.getTypeInfo(expr)
	switch t := expr.(type) {
	case *ast.Ident:
		return fmt.Sprintf("n, %s, err = %s(%s, %s)", varName, info.Unmarshaler, n, buf)
	case *ast.StarExpr:
		eltType := g.ExprToString(t.X)
		// FIX: Added "var err error;" to declare err locally
		eltUnmarshalFn := fmt.Sprintf("func(n int, b []byte, v *%s) (int, error) { var err error; %s; return n, err }", eltType, g.getGoUnmarshalExpr(t.X, "n", "b", "(*v)"))
		return fmt.Sprintf("n, %s, err = bstd.UnmarshalPointer[%s](%s, %s, %s)", varName, eltType, n, buf, eltUnmarshalFn)
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("n, %s, err = bstd.UnmarshalTime(%s, %s)", varName, n, buf)
		}
		return fmt.Sprintf("n, err = %s.Unmarshal(%s, %s)", varName, n, buf)
	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		if eltInfo.TypeName == "byte" {
			return fmt.Sprintf("n, %s, err = bstd.UnmarshalBytesCopied(%s, %s)", varName, n, buf)
		}
		// FIX: Added "var err error;" to declare err locally
		eltUnmarshaler := fmt.Sprintf("func(n int, b []byte, v *%s) (int, error) { var err error; %s; return n, err }", eltInfo.TypeName, g.getGoUnmarshalExpr(t.Elt, "n", "b", "(*v)"))
		return fmt.Sprintf("n, %s, err = bstd.UnmarshalSlice[%s](%s, %s, %s)", varName, eltInfo.TypeName, n, buf, eltUnmarshaler)
	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		// FIX: Added "var err error;" to declare err locally in both key and value unmarshalers
		keyUnmarshal := fmt.Sprintf("func(n int, b []byte, k *%s) (int, error) { var err error; %s; return n, err }", keyInfo.TypeName, g.getGoUnmarshalExpr(t.Key, "n", "b", "(*k)"))
		valUnmarshal := fmt.Sprintf("func(n int, b []byte, v *%s) (int, error) { var err error; %s; return n, err }", valInfo.TypeName, g.getGoUnmarshalExpr(t.Value, "n", "b", "(*v)"))
		return fmt.Sprintf("n, %s, err = bstd.UnmarshalMap[%s, %s](%s, %s, %s, %s)", varName, keyInfo.TypeName, valInfo.TypeName, n, buf, keyUnmarshal, valUnmarshal)
	default:
		return fmt.Sprintf("n, %s, err = %s(%s, %s)", varName, info.Unmarshaler, n, buf)
	}
}

// Type Info Logic

type typeGenInfo struct {
	TypeName      string
	Marshaler     string
	Unmarshaler   string
	TestGenerator string
	TestComparer  string
	IsFixedSize   bool
}

func (g *generator) getTypeInfo(expr ast.Expr) typeGenInfo {
	typeName := g.ExprToString(expr)

	switch t := expr.(type) {
	case *ast.Ident:
		if _, ok := g.TypeSpecs[t.Name]; ok {
			return typeGenInfo{
				TypeName:      t.Name,
				TestGenerator: fmt.Sprintf("Generate%s", t.Name),
				TestComparer:  fmt.Sprintf("Compare%s", t.Name),
			}
		}
		title := strings.Title(t.Name)
		if t.Name == "byte" || t.Name == "uint8" {
			title = "Byte"
			typeName = "byte"
		}
		if t.Name == "rune" {
			title = "Int32"
			typeName = "rune"
		}
		return typeGenInfo{
			TypeName:      typeName,
			Marshaler:     "bstd.Marshal" + title,
			Unmarshaler:   "bstd.Unmarshal" + title,
			TestGenerator: "btst.Generate" + title,
			TestComparer:  fmt.Sprintf("btst.ComparePrimitive[%s]", typeName),
			IsFixedSize:   common.FixedSizeTypes[t.Name],
		}

	case *ast.StarExpr:
		eltInfo := g.getTypeInfo(t.X)
		return typeGenInfo{
			TypeName:      "*" + eltInfo.TypeName,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) *%s { return btst.GeneratePointer(r, d, %s) }", eltInfo.TypeName, eltInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("func(a, b *%s) error { return btst.ComparePointer(a, b, %s) }", eltInfo.TypeName, eltInfo.TestComparer),
		}

	case *ast.SelectorExpr:
		sel := g.ExprToString(t)
		if sel == "time.Time" {
			return typeGenInfo{
				TypeName:      "time.Time",
				Marshaler:     "bstd.MarshalTime",
				Unmarshaler:   "bstd.UnmarshalTime",
				TestGenerator: "btst.GenerateTime",
				TestComparer:  "btst.ComparePrimitive[time.Time]",
				IsFixedSize:   true,
			}
		}
		return typeGenInfo{
			TypeName:      sel,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) %s { return *new(%s) }", sel, sel),
			TestComparer:  fmt.Sprintf("btst.ComparePrimitive[%s]", sel),
		}

	case *ast.ArrayType:
		eltInfo := g.getTypeInfo(t.Elt)
		return typeGenInfo{
			TypeName:      typeName,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) %s { return btst.GenerateSlice(r, d, %s) }", typeName, eltInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("func(a, b %s) error { return btst.CompareSlice(a, b, %s) }", typeName, eltInfo.TestComparer),
		}

	case *ast.MapType:
		keyInfo := g.getTypeInfo(t.Key)
		valInfo := g.getTypeInfo(t.Value)
		return typeGenInfo{
			TypeName:      typeName,
			TestGenerator: fmt.Sprintf("func(r *rand.Rand, d int) %s { return btst.GenerateMap(r, d, %s, %s) }", typeName, keyInfo.TestGenerator, valInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("func(a, b %s) error { return btst.CompareMap(a, b, %s) }", typeName, valInfo.TestComparer),
		}
	}
	return typeGenInfo{TypeName: typeName}
}

func init() {
	//golang.NewGenerator(ctx)
}

// generator := 
// 			code, err := generator.GenerateGo(types)
// 			if err != nil {
// 				log.Fatalf("Go generation failed: %v", err)
// 			}
// 			testCode, err := generator.GenerateGoTests(types)
// 			if err != nil {
// 				log.Fatalf("Go test generation failed: %v", err)
// 			}
// 			goFile := filepath.Join(outputDir, fmt.Sprintf("%s_benc.go", baseName))
// 			goTestFile := filepath.Join(outputDir, fmt.Sprintf("%s_benc_test.go", baseName))
// 			writeFile(goFile, code)
// 			writeFile(goTestFile, testCode)