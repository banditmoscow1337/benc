package cpp

import (
	"bytes"
	"fmt"
	"go/ast"
	"strings"

	"github.com/banditmoscow1337/benc/cmd/internal/common"
)

type generator struct {
	*common.Context
	buf bytes.Buffer
}

func New(ctx *common.Context) common.Generator {
	return &generator{Context: ctx}
}

func (g *generator) Generate() (err error) {
	g.printf("// Code generated by benc generator; DO NOT EDIT.\n")
	g.printf("#pragma once\n\n")
	g.printf("#include \"std.hpp\"\n")
	g.printf("#include <vector>\n")
	g.printf("#include <string>\n")
	g.printf("#include <map>\n")
	g.printf("#include <optional>\n")
	g.printf("#include <variant>\n\n")
	
	// Open namespace
	g.printf("namespace %s {\n\n", g.PkgName)

	// Forward declarations
	for _, ts := range g.Types {
		g.printf("struct %s;\n", ts.Name.Name)
	}
	g.printf("\n")

	// Struct Definitions
	for _, ts := range g.Types {
		if err = g.generateCppStruct(ts); err != nil {
			return fmt.Errorf("generating struct %s: %w", ts.Name.Name, err)
		}
	}

	// Close namespace
	g.printf("} // namespace %s\n", g.PkgName)

	common.WriteFile(g.Context, g.buf.Bytes(), "hpp")
	g.buf.Reset()

	return
}

func (g *generator) generateCppStruct(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	_, ok := ts.Type.(*ast.StructType)
	if !ok {
		// Handle Map/Array aliases if necessary, for now skipping aliases
		return nil
	}

	g.printf("struct %s {\n", name)

	// Fields
	supportedFields := g.GetSupportedFields(ts)
	for _, field := range supportedFields {
		cppType := g.toCppType(field.Type)
		for _, fName := range field.Names {
			g.printf("\t%s %s;\n", cppType, fName.Name)
		}
	}
	g.printf("\n")

	// Size Method
	g.printf("\tstd::size_t Size() const {\n")
	g.printf("\t\tstd::size_t s = 0;\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\t\ts += %s;\n", g.getSizeExpr(field.Type, fName.Name))
		}
	}
	g.printf("\t\treturn s;\n")
	g.printf("\t}\n\n")

	// Marshal Method
	g.printf("\tstd::size_t Marshal(std::span<std::byte> b, std::size_t n) const {\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\t\tn = %s;\n", g.getMarshalExpr(field.Type, "n", "b", fName.Name))
		}
	}
	g.printf("\t\treturn n;\n")
	g.printf("\t}\n\n")

	// Unmarshal Method
	// Returns bstd::Result<size_t> (new offset or error)
	g.printf("\tbstd::Result<std::size_t> Unmarshal(std::span<const std::byte> b, std::size_t n) {\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			g.printf("\t\t{\n")
			g.printf("\t\t\tauto res = %s;\n", g.getUnmarshalExpr(field.Type, "n", "b"))
			g.printf("\t\t\tif (auto* err = std::get_if<bstd::Error>(&res)) return *err;\n")
			g.printf("\t\t\tauto& [val, off] = std::get<bstd::UnmarshalResult<%s>>(res);\n", g.toCppType(field.Type))
			g.printf("\t\t\tthis->%s = std::move(val);\n", fName.Name)
			g.printf("\t\t\tn = off;\n")
			g.printf("\t\t}\n")
		}
	}
	g.printf("\t\treturn n;\n")
	g.printf("\t}\n")

	g.printf("};\n\n")
	return nil
}

// -----------------------------------------------------------------------------
// C++ Test Generation
// -----------------------------------------------------------------------------

func (g *generator) Tests() {
	g.printf("// Code generated by benc generator; DO NOT EDIT.\n")
	g.printf("#include \"gen.h\"\n")
	g.printf("#include \"%s.hpp\"\n", g.PkgName) // Assumes output file is pkgname.hpp
	g.printf("#include <iostream>\n\n")

	g.printf("using namespace %s;\n\n", g.PkgName)

	// Generate Generators and Comparers
	for _, ts := range g.Types {
		g.generateCppTestGenerator(ts)
		g.generateCppTestComparer(ts)
	}

	// Generate Test Main Body
	g.printf("int main() {\n")
	g.printf("\tstd::mt19937 rng(std::random_device{}());\n")
	g.printf("\tint errors = 0;\n\n")

	for _, ts := range g.Types {
		if _, ok := ts.Type.(*ast.StructType); ok {
			name := ts.Name.Name
			g.printf("\t// Test %s\n", name)
			g.printf("\t{\n")
			g.printf("\t\tauto original = Generate%s(rng, bstd::gen::MaxDepth);\n", name)
			g.printf("\t\tstd::size_t s = original.Size();\n")
			g.printf("\t\tstd::vector<std::byte> buf(s);\n")
			g.printf("\t\tstd::size_t n = original.Marshal(buf, 0);\n")
			g.printf("\t\tif (n != s) { std::cerr << \"[FAIL] %s: Size mismatch\" << std::endl; errors++; }\n", name)
			g.printf("\t\telse {\n")
			g.printf("\t\t\t%s copy;\n", name)
			g.printf("\t\t\tauto res = copy.Unmarshal(buf, 0);\n")
			g.printf("\t\t\tif (std::holds_alternative<bstd::Error>(res)) { std::cerr << \"[FAIL] %s: Unmarshal error\" << std::endl; errors++; }\n", name)
			g.printf("\t\t\telse {\n")
			g.printf("\t\t\t\tif (auto err = Compare%s(original, copy)) {\n", name)
			g.printf("\t\t\t\t\tstd::cerr << \"[FAIL] %s: \" << *err << std::endl; errors++;\n", name)
			g.printf("\t\t\t\t}\n")
			g.printf("\t\t\t}\n")
			g.printf("\t\t}\n")
			g.printf("\t}\n\n")
		}
	}

	g.printf("\tif (errors == 0) std::cout << \"All tests passed!\" << std::endl;\n")
	g.printf("\treturn errors > 0 ? 1 : 0;\n")
	g.printf("}\n")

	common.WriteFile(g.Context, g.buf.Bytes(), "test.cpp")
	g.buf.Reset()
}

func (g *generator) generateCppTestGenerator(ts *ast.TypeSpec) {
	name := ts.Name.Name
	st, ok := ts.Type.(*ast.StructType)
	if !ok { return }

	g.printf("template<bstd::gen::URBG Gen>\n")
	g.printf("%s Generate%s(Gen& g, int depth) {\n", name, name)
	g.printf("\tif (depth <= 0) return %s{};\n", name)
	g.printf("\t%s obj;\n", name)
	
	for _, field := range st.Fields.List {
		if g.ShouldIgnoreField(field) { continue }
		for _, fName := range field.Names {
			g.printf("\tobj.%s = %s;\n", fName.Name, g.getTestGenExpr(field.Type))
		}
	}
	g.printf("\treturn obj;\n")
	g.printf("}\n\n")
}

func (g *generator) generateCppTestComparer(ts *ast.TypeSpec) {
	name := ts.Name.Name
	st, ok := ts.Type.(*ast.StructType)
	if !ok { return }

	g.printf("bstd::gen::CompareResult Compare%s(const %s& a, const %s& b) {\n", name, name, name)
	for _, field := range st.Fields.List {
		if g.ShouldIgnoreField(field) { continue }
		for _, fName := range field.Names {
			g.printf("\tif (auto err = bstd::gen::CompareField(\"%s\", [&]() { return %s; })) return err;\n", 
				fName.Name, g.getTestCompareExpr(field.Type, "a."+fName.Name, "b."+fName.Name))
		}
	}
	g.printf("\treturn std::nullopt;\n")
	g.printf("}\n\n")
}

// -----------------------------------------------------------------------------
// Logic & Mapping
// -----------------------------------------------------------------------------

func (g *generator) toCppType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int": return "int64_t"
		case "int8": return "int8_t"
		case "int16": return "int16_t"
		case "int32": return "int32_t"
		case "int64": return "int64_t"
		case "uint": return "uint64_t"
		case "uint8", "byte": return "uint8_t"
		case "uint16": return "uint16_t"
		case "uint32": return "uint32_t"
		case "uint64": return "uint64_t"
		case "float32": return "float"
		case "float64": return "double"
		case "bool": return "bool"
		case "string": return "std::string"
		default: return t.Name // Custom types
		}
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return "bstd::time_point"
		}
		return g.ExprToString(t)
	case *ast.StarExpr:
		return fmt.Sprintf("std::optional<%s>", g.toCppType(t.X))
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" { // []byte
			return "std::vector<std::byte>"
		}
		return fmt.Sprintf("std::vector<%s>", g.toCppType(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("std::map<%s, %s>", g.toCppType(t.Key), g.toCppType(t.Value))
	}
	return "void"
}

func (g *generator) getSizeExpr(expr ast.Expr, val string) string {
	// Custom Structs
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		// If it's a map alias or struct, it has a Size() method
		return fmt.Sprintf("%s.Size()", val)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int": return fmt.Sprintf("bstd::size_int64(%s)", val)
		case "uint": return fmt.Sprintf("bstd::size_uint64(%s)", val)
		case "string": return fmt.Sprintf("bstd::size_string(%s)", val)
		case "byte", "uint8": return "bstd::size_uint8()" // Fixed
		case "bool": return "bstd::size_bool()"
		// Fixed size primitives
		case "int8", "int16", "int32", "int64", "uint16", "uint32", "uint64", "float32", "float64":
			return fmt.Sprintf("bstd::size_%s()", t.Name)
		default: return fmt.Sprintf("%s.Size()", val)
		}
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return "bstd::size_time()"
		}
		return fmt.Sprintf("%s.Size()", val)
	case *ast.StarExpr:
		// Optional
		subSizer := g.makeLambdaSizer(t.X)
		return fmt.Sprintf("bstd::size_pointer(%s, %s)", val, subSizer)
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" {
			// Cast vector<byte> to span<byte> for sizing logic, or just use size_bytes
			// std.hpp: size_bytes takes span<const byte>
			// But vector<byte> isn't vector<uint8_t>. Wait, toCppType mapped []byte to vector<std::byte>.
			return fmt.Sprintf("bstd::size_bytes(%s)", val)
		}
		subSizer := g.makeLambdaSizer(t.Elt)
		return fmt.Sprintf("bstd::size_slice(%s, %s)", val, subSizer)
	case *ast.MapType:
		kSizer := g.makeLambdaSizer(t.Key)
		vSizer := g.makeLambdaSizer(t.Value)
		return fmt.Sprintf("bstd::size_map(%s, %s, %s)", val, kSizer, vSizer)
	}
	return "0"
}

func (g *generator) getMarshalExpr(expr ast.Expr, n, buf, val string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s.Marshal(%s, %s)", val, buf, n)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int": return fmt.Sprintf("bstd::marshal_int64(%s, %s, %s)", buf, n, val)
		case "uint": return fmt.Sprintf("bstd::marshal_uint64(%s, %s, %s)", buf, n, val)
		default: return fmt.Sprintf("bstd::marshal_%s(%s, %s, %s)", t.Name, buf, n, val)
		}
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("bstd::marshal_time(%s, %s, %s)", buf, n, val)
		}
		return fmt.Sprintf("%s.Marshal(%s, %s)", val, buf, n)
	case *ast.StarExpr:
		lam := g.makeLambdaMarshaler(t.X)
		return fmt.Sprintf("bstd::marshal_pointer(%s, %s, %s, %s)", buf, n, val, lam)
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" { // Special case for bytes
			// vector<byte> to span<byte> conversion happens implicitly
			return fmt.Sprintf("bstd::marshal_bytes(%s, %s, %s)", buf, n, val)
		}
		lam := g.makeLambdaMarshaler(t.Elt)
		return fmt.Sprintf("bstd::marshal_slice(%s, %s, %s, %s)", buf, n, val, lam)
	case *ast.MapType:
		kLam := g.makeLambdaMarshaler(t.Key)
		vLam := g.makeLambdaMarshaler(t.Value)
		return fmt.Sprintf("bstd::marshal_map(%s, %s, %s, %s, %s)", buf, n, val, kLam, vLam)
	}
	return n
}

func (g *generator) getUnmarshalExpr(expr ast.Expr, n, buf string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		// Structs have Unmarshal method that returns Result<size_t>
		// We need to wrap it to match functional style: (b, n) -> Result<T>
		// Actually, generated Unmarshal method on struct returns new offset.
		// Wait, std.hpp unmarshal helpers return UnmarshalResult<T> {val, off}.
		// For structs, we probably want to instantiate T, call T.Unmarshal, return {T, off}.
		return fmt.Sprintf("[](std::span<const std::byte> b, std::size_t n) -> bstd::Result<%s> { %s v; auto r = v.Unmarshal(b, n); if(auto* e = std::get_if<bstd::Error>(&r)) return *e; return bstd::UnmarshalResult<%s>{std::move(v), std::get<std::size_t>(r)}; }(%s, %s)", typeName, typeName, typeName, buf, n)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "int": return fmt.Sprintf("bstd::unmarshal_int64(%s, %s)", buf, n)
		case "uint": return fmt.Sprintf("bstd::unmarshal_uint64(%s, %s)", buf, n)
		default: return fmt.Sprintf("bstd::unmarshal_%s(%s, %s)", t.Name, buf, n)
		}
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("bstd::unmarshal_time(%s, %s)", buf, n)
		}
		// Similar wrap for external structs if they follow the pattern
		return fmt.Sprintf("...custom...(%s, %s)", buf, n) 
	case *ast.StarExpr:
		lam := g.makeLambdaUnmarshaler(t.X)
		return fmt.Sprintf("bstd::unmarshal_pointer<%s>(%s, %s, %s)", g.toCppType(t.X), buf, n, lam)
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" {
			return fmt.Sprintf("bstd::unmarshal_bytes_copied(%s, %s)", buf, n)
		}
		lam := g.makeLambdaUnmarshaler(t.Elt)
		return fmt.Sprintf("bstd::unmarshal_slice<%s>(%s, %s, %s)", g.toCppType(t.Elt), buf, n, lam)
	case *ast.MapType:
		kLam := g.makeLambdaUnmarshaler(t.Key)
		vLam := g.makeLambdaUnmarshaler(t.Value)
		return fmt.Sprintf("bstd::unmarshal_map<%s, %s>(%s, %s, %s, %s)", g.toCppType(t.Key), g.toCppType(t.Value), buf, n, kLam, vLam)
	}
	return ""
}

// Lambda Helpers for std.hpp Higher-Order Functions

func (g *generator) makeLambdaSizer(t ast.Expr) string {
	cppType := g.toCppType(t)
	// If it's a primitive fixed type, std.hpp might expect no args, or just call size_X().
	// But slice/map helpers in std.hpp expect a Callable: (const T&) -> size_t.
	return fmt.Sprintf("[](const %s& v) { return %s; }", cppType, g.getSizeExpr(t, "v"))
}

func (g *generator) makeLambdaMarshaler(t ast.Expr) string {
	cppType := g.toCppType(t)
	return fmt.Sprintf("[](std::span<std::byte> b, std::size_t n, const %s& v) { return %s; }", cppType, g.getMarshalExpr(t, "n", "b", "v"))
}

func (g *generator) makeLambdaUnmarshaler(t ast.Expr) string {
	// std.hpp expects: (span, size) -> Result<T>
	return fmt.Sprintf("[](std::span<const std::byte> b, std::size_t n) { return %s; }", g.getUnmarshalExpr(t, "n", "b"))
}

// Test Gen Helpers

func (g *generator) getTestGenExpr(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string": return "bstd::gen::GenerateString(g, depth)"
		case "int": return "bstd::gen::GenerateInt64(g, depth)"
		// ... map other primitives to gen.h functions
		default: 
			if _, ok := g.TypeSpecs[t.Name]; ok {
				return fmt.Sprintf("Generate%s(g, depth - 1)", t.Name)
			}
			return fmt.Sprintf("bstd::gen::Generate%s%s(g, depth)", strings.ToUpper(t.Name[:1]), t.Name[1:])
		}
	case *ast.StarExpr:
		return fmt.Sprintf("bstd::gen::GeneratePointer<%s>(g, depth, [](auto& g, int d) { return %s; })", g.toCppType(t.X), g.getTestGenExpr(t.X))
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" {
			return "bstd::gen::GenerateBytes(g, depth)"
		}
		return fmt.Sprintf("bstd::gen::GenerateSlice<%s>(g, depth, [](auto& g, int d) { return %s; })", g.toCppType(t.Elt), g.getTestGenExpr(t.Elt))
	case *ast.MapType:
		return fmt.Sprintf("bstd::gen::GenerateMap<%s, %s>(g, depth, [](auto& g, int d) { return %s; }, [](auto& g, int d) { return %s; })", 
			g.toCppType(t.Key), g.toCppType(t.Value), g.getTestGenExpr(t.Key), g.getTestGenExpr(t.Value))
	}
	return "{}"
}

func (g *generator) getTestCompareExpr(expr ast.Expr, a, b string) string {
	switch t := expr.(type) {
	case *ast.Ident:
		if _, ok := g.TypeSpecs[t.Name]; ok {
			return fmt.Sprintf("Compare%s(%s, %s)", t.Name, a, b)
		}
		return fmt.Sprintf("bstd::gen::ComparePrimitive(%s, %s)", a, b)
	case *ast.ArrayType:
		if g.toCppType(t.Elt) == "uint8_t" {
			// span cast for bytes comparison
			return fmt.Sprintf("bstd::gen::CompareBytes(%s, %s)", a, b)
		}
		return fmt.Sprintf("bstd::gen::CompareSlice(%s, %s, [](const auto& x, const auto& y) { return %s; })", a, b, g.getTestCompareExpr(t.Elt, "x", "y"))
	case *ast.StarExpr:
		return fmt.Sprintf("bstd::gen::ComparePointer(%s, %s, [](const auto& x, const auto& y) { return %s; })", a, b, g.getTestCompareExpr(t.X, "x", "y"))
	case *ast.MapType:
		return fmt.Sprintf("bstd::gen::CompareMap(%s, %s, [](const auto& x, const auto& y) { return %s; })", a, b, g.getTestCompareExpr(t.Value, "x", "y"))
	}
	return "std::nullopt"
}

func (g *generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}