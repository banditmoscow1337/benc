package javascript

import (
	"bytes"
	"fmt"
	"go/ast"
	"strings"

	"github.com/banditmoscow1337/benc/cmd/internal/common"
)

type Generator struct {
	*common.Context
	buf bytes.Buffer
}

func New(ctx *common.Context) *Generator {
	return &Generator{Context: ctx}
}

// -----------------------------------------------------------------------------
// JAVASCRIPT GENERATION
// -----------------------------------------------------------------------------


func (g *Generator) Generate() (err error) {
	g.printf("/**\n * Code generated by benc generator; DO NOT EDIT.\n */\n\n")
	g.printf("const bstd = require('./std.js');\n\n")

	for _, ts := range g.Types {
		if err = g.generateJSClass(ts); err != nil {
			return
		}
	}
	g.printf("module.exports = {\n")
	for _, ts := range g.Types {
		g.printf("\t%s,\n", ts.Name.Name)
	}
	g.printf("};\n")

	common.WriteFile(g.Context, g.buf.Bytes(), "js")

	g.buf.Reset()

	return
}

func (g *Generator) generateJSClass(ts *ast.TypeSpec) error {
	name := ts.Name.Name
	g.printf("class %s {\n", name)

	// Fields
	supportedFields := g.GetSupportedFields(ts)

	// Constructor
	g.printf("\tconstructor() {\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			def := g.getJSDefaultValue(field.Type)
			g.printf("\t\tthis.%s = %s;\n", fName.Name, def)
		}
	}
	g.printf("\t}\n\n")

	// Size Method
	g.printf("\tsize() {\n\t\tlet s = 0;\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			// JS access is this.FieldName
			accessor := fmt.Sprintf("this.%s", fName.Name)
			g.printf("\t\ts += %s;\n", g.getJSSizeExpr(field.Type, accessor))
		}
	}
	g.printf("\t\treturn s;\n\t}\n\n")

	// Marshal Method
	g.printf("\tmarshal(n, b) {\n")
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			accessor := fmt.Sprintf("this.%s", fName.Name)
			g.printf("\t\tn = %s;\n", g.getJSMarshalExpr(field.Type, "n", "b", accessor))
		}
	}
	g.printf("\t\treturn n;\n\t}\n\n")

	// Unmarshal Method
	g.printf("\tunmarshal(n, b) {\n")
	g.printf("\t\tlet v;\n") // generic temp var
	for _, field := range supportedFields {
		for _, fName := range field.Names {
			target := fmt.Sprintf("this.%s", fName.Name)
			g.printf("\t\t%s\n", g.getJSUnmarshalExpr(field.Type, "n", "b", target))
		}
	}
	g.printf("\t\treturn [n, this];\n\t}\n") // JS Unmarshal returns [offset, object] usually
	g.printf("}\n\n")

	return nil
}

// -----------------------------------------------------------------------------
// JAVASCRIPT TEST GENERATION
// -----------------------------------------------------------------------------

func (g *Generator) Tests() {
	g.printf("/**\n * Code generated by benc generator; DO NOT EDIT.\n */\n\n")
	g.printf("const bstd = require('./std.js');\n")
	g.printf("const gen = require('./gen.js');\n")
	g.printf("const { %s } = require('./%s_benc.js');\n\n", g.getAllTypeNames(), g.PkgName)

	// Generators
	for _, ts := range g.Types {
		g.generateJSTestGenerator(ts)
	}

	// Comparers
	for _, ts := range g.Types {
		g.generateJSTestComparer(ts)
	}

	// Main Test Block
	g.printf("describe('Generated Benc Tests for %s', () => {\n", g.PkgName)

	// Find top level struct (usually the first one or one that contains others)
	// We'll test all structs to be thorough
	for _, ts := range g.Types {
		if _, ok := ts.Type.(*ast.StructType); ok {
			name := ts.Name.Name
			g.printf("\ttest('%s Serialization', () => {\n", name)
			g.printf("\t\tconst original = Generate%s(gen.MaxDepth);\n", name)
			g.printf("\t\tconst s = original.size();\n", name)
			g.printf("\t\tconst buf = new Uint8Array(s);\n")
			g.printf("\t\tconst n = original.marshal(0, buf);\n")
			g.printf("\t\texpect(n).toBe(s);\n\n")
			g.printf("\t\tconst copy = new %s();\n", name)
			g.printf("\t\tconst [readN, _] = copy.unmarshal(0, buf);\n")
			g.printf("\t\texpect(readN).toBe(s);\n\n")
			g.printf("\t\tconst err = Compare%s(original, copy);\n", name)
			g.printf("\t\texpect(err).toBeNull();\n")
			g.printf("\t});\n\n")
		}
	}

	g.printf("});\n")

	common.WriteFile(g.Context, g.buf.Bytes(), "test.js")

	g.buf.Reset()
}

func (g *Generator) generateJSTestGenerator(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("function Generate%s(depth) {\n", name)
	g.printf("\tif (depth <= 0) return new %s();\n", name)

	switch t := ts.Type.(type) {
	case *ast.StructType:
		g.printf("\tconst obj = new %s();\n", name)
		for _, field := range t.Fields.List {
			if g.ShouldIgnoreField(field) || g.IsUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				gen := g.getJSTypeInfo(field.Type).TestGenerator
				g.printf("\tobj.%s = %s;\n", fName.Name, gen)
			}
		}
		g.printf("\treturn obj;\n")
	case *ast.MapType, *ast.ArrayType:
		// Aliases
		gen := g.getJSTypeInfo(ts.Type).TestGenerator
		g.printf("\treturn %s;\n", gen)
	}
	g.printf("}\n\n")
}

func (g *Generator) generateJSTestComparer(ts *ast.TypeSpec) {
	name := ts.Name.Name
	g.printf("function Compare%s(a, b) {\n", name)
	switch t := ts.Type.(type) {
	case *ast.StructType:
		for _, field := range t.Fields.List {
			if g.ShouldIgnoreField(field) || g.IsUnsupportedType(field.Type) {
				continue
			}
			for _, fName := range field.Names {
				comparer := g.getJSTypeInfo(field.Type).TestComparer
				g.printf("\terr = gen.CompareField('%s', () => %s(a.%s, b.%s));\n", fName.Name, comparer, fName.Name, fName.Name)
				g.printf("\tif (err) return err;\n")
			}
		}
		g.printf("\treturn null;\n")
	default:
		comparer := g.getJSTypeInfo(t).TestComparer
		g.printf("\treturn %s(a, b);\n", comparer)
	}
	g.printf("}\n\n")
}

// -----------------------------------------------------------------------------
// HELPERS
// -----------------------------------------------------------------------------

func (g *Generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) getAllTypeNames() string {
	names := make([]string, len(g.Types))
	for i, t := range g.Types {
		names[i] = t.Name.Name
	}
	return strings.Join(names, ", ")
}

// JS Expression Logic

func (g *Generator) getJSDefaultValue(expr ast.Expr) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return "null"
	}

	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "bool":
			return "false"
		case "string":
			return `""`
		case "int", "int8", "int16", "int32", "uint", "uint8", "uint16", "uint32", "byte", "float32", "float64":
			return "0"
		case "int64", "uint64":
			return "0n" // BigInt
		case "rune":
			return "0"
		default:
			return "null"
		}
	case *ast.ArrayType:
		if isByteSlice(t) {
			return "new Uint8Array(0)"
		}
		return "[]"
	case *ast.MapType:
		return "new Map()"
	case *ast.StarExpr:
		return "null"
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return "new Date()"
		}
		return "null"
	default:
		return "null"
	}
}

func (g *Generator) getJSSizeExpr(expr ast.Expr, accessor string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s.size()", accessor)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		// Basic types
		fn := "size" + strings.Title(t.Name)
		if t.Name == "byte" {
			fn = "sizeByte"
		}
		if t.Name == "rune" {
			fn = "sizeInt32"
		}
		// Fix casing for std.js
		fn = "bstd." + fn
		return fmt.Sprintf("%s(%s)", fn, accessor)
	case *ast.StarExpr:
		// Pointer: bstd.sizePointer(v, sizeFn)
		// We need a sizeFn for the element.
		eltSizer := fmt.Sprintf("(v) => %s", g.getJSSizeExpr(t.X, "v"))
		return fmt.Sprintf("bstd.sizePointer(%s, %s)", accessor, eltSizer)
	case *ast.ArrayType:
		if isByteSlice(t) {
			return fmt.Sprintf("bstd.sizeBytes(%s)", accessor)
		}
		eltSizer := fmt.Sprintf("(v) => %s", g.getJSSizeExpr(t.Elt, "v"))
		return fmt.Sprintf("bstd.sizeSlice(%s, %s)", accessor, eltSizer)
	case *ast.MapType:
		keySizer := fmt.Sprintf("(k) => %s", g.getJSSizeExpr(t.Key, "k"))
		valSizer := fmt.Sprintf("(v) => %s", g.getJSSizeExpr(t.Value, "v"))
		return fmt.Sprintf("bstd.sizeMap(%s, %s, %s)", accessor, keySizer, valSizer)
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return "bstd.sizeTime()"
		}
		return fmt.Sprintf("%s.size()", accessor)
	default:
		return "0"
	}
}

func (g *Generator) getJSMarshalExpr(expr ast.Expr, n, b, accessor string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s.marshal(%s, %s)", accessor, n, b)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		fn := "marshal" + strings.Title(t.Name)
		if t.Name == "byte" {
			fn = "marshalByte"
		}
		if t.Name == "rune" {
			fn = "marshalInt32"
		}
		return fmt.Sprintf("bstd.%s(%s, %s, %s)", fn, n, b, accessor)
	case *ast.StarExpr:
		eltMarshal := fmt.Sprintf("(n, b, v) => %s", g.getJSMarshalExpr(t.X, "n", "b", "v"))
		// Fix: result of recursive call assigns to n, so we wrap it
		if _, ok := t.X.(*ast.Ident); ok || isBasicType(t.X) {
			// Basic types return n
			eltMarshal = fmt.Sprintf("(n, b, v) => %s", g.getJSMarshalExpr(t.X, "n", "b", "v"))
		}
		return fmt.Sprintf("bstd.marshalPointer(%s, %s, %s, %s)", n, b, accessor, eltMarshal)
	case *ast.ArrayType:
		if isByteSlice(t) {
			return fmt.Sprintf("bstd.marshalBytes(%s, %s, %s)", n, b, accessor)
		}
		eltMarshal := fmt.Sprintf("(n, b, v) => %s", g.getJSMarshalExpr(t.Elt, "n", "b", "v"))
		return fmt.Sprintf("bstd.marshalSlice(%s, %s, %s, %s)", n, b, accessor, eltMarshal)
	case *ast.MapType:
		keyMarshal := fmt.Sprintf("(n, b, k) => %s", g.getJSMarshalExpr(t.Key, "n", "b", "k"))
		valMarshal := fmt.Sprintf("(n, b, v) => %s", g.getJSMarshalExpr(t.Value, "n", "b", "v"))
		return fmt.Sprintf("bstd.marshalMap(%s, %s, %s, %s, %s)", n, b, accessor, keyMarshal, valMarshal)
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("bstd.marshalTime(%s, %s, %s)", n, b, accessor)
		}
		return fmt.Sprintf("%s.marshal(%s, %s)", accessor, n, b)
	default:
		return n
	}
}

func (g *Generator) getJSUnmarshalExpr(expr ast.Expr, n, b, target string) string {
	typeName := g.ExprToString(expr)
	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("[%s, _] = %s.unmarshal(%s, %s);", n, target, n, b)
	}

	if _, ok := g.TypeSpecs[typeName]; ok {
		return fmt.Sprintf("%s = new %s();\n\t\t[%s, _] = %s.unmarshal(%s, %s);", target, typeName, n, target, n, b)
	}

	switch t := expr.(type) {
	case *ast.Ident:
		fn := "unmarshal" + strings.Title(t.Name)
		if t.Name == "byte" {
			fn = "unmarshalByte"
		}
		if t.Name == "rune" {
			fn = "unmarshalInt32"
		}
		return fmt.Sprintf("[%s, v] = bstd.%s(%s, %s);\n\t\t%s = v;", n, fn, n, b, target)
	case *ast.StarExpr:
		eltUnmarshal := fmt.Sprintf("(n, b) => {\n\t\t\tlet v;\n\t\t\t%s\n\t\t\treturn [n, v];\n\t\t}", g.getJSUnmarshalExpr(t.X, "n", "b", "v"))
		return fmt.Sprintf("[%s, %s] = bstd.unmarshalPointer(%s, %s, %s);", n, target, n, b, eltUnmarshal)

	case *ast.ArrayType:
		if isByteSlice(t) {
			return fmt.Sprintf("[%s, %s] = bstd.unmarshalBytesCopied(%s, %s);", n, target, n, b)
		}
		eltUnmarshal := fmt.Sprintf("(n, b) => {\n\t\t\tlet v;\n\t\t\t%s\n\t\t\treturn [n, v];\n\t\t}", g.getJSUnmarshalExpr(t.Elt, "n", "b", "v"))
		return fmt.Sprintf("[%s, %s] = bstd.unmarshalSlice(%s, %s, %s);", n, target, n, b, eltUnmarshal)

	case *ast.MapType:
		keyUnmarshal := fmt.Sprintf("(n, b) => {\n\t\t\tlet v;\n\t\t\t%s\n\t\t\treturn [n, v];\n\t\t}", g.getJSUnmarshalExpr(t.Key, "n", "b", "v"))
		valUnmarshal := fmt.Sprintf("(n, b) => {\n\t\t\tlet v;\n\t\t\t%s\n\t\t\treturn [n, v];\n\t\t}", g.getJSUnmarshalExpr(t.Value, "n", "b", "v"))
		return fmt.Sprintf("[%s, %s] = bstd.unmarshalMap(%s, %s, %s, %s);", n, target, n, b, keyUnmarshal, valUnmarshal)

	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return fmt.Sprintf("[%s, %s] = bstd.unmarshalTime(%s, %s);", n, target, n, b)
		}
		return fmt.Sprintf("%s = new %s();\n\t\t[%s, _] = %s.unmarshal(%s, %s);", target, g.ExprToString(t), n, target, n, b)
	default:
		return ""
	}
}

type typeGenInfo struct {
	TestGenerator string
	TestComparer  string
}

func (g *Generator) getJSTypeInfo(expr ast.Expr) typeGenInfo {
	switch t := expr.(type) {
	case *ast.Ident:
		if _, ok := g.TypeSpecs[t.Name]; ok {
			return typeGenInfo{
				TestGenerator: fmt.Sprintf("Generate%s(depth - 1)", t.Name),
				TestComparer:  fmt.Sprintf("Compare%s", t.Name),
			}
		}
		title := strings.Title(t.Name)
		switch t.Name {
		case "byte", "uint8":
			title = "Byte"
		case "rune":
			title = "Rune"
		}
		return typeGenInfo{
			TestGenerator: fmt.Sprintf("gen.Generate%s(depth - 1)", title),
			TestComparer:  "gen.ComparePrimitive",
		}
	case *ast.StarExpr:
		eltInfo := g.getJSTypeInfo(t.X)
		return typeGenInfo{
			TestGenerator: fmt.Sprintf("gen.GeneratePointer(depth - 1, (d) => %s)", eltInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("(a, b) => gen.ComparePointer(a, b, %s)", eltInfo.TestComparer),
		}
	case *ast.ArrayType:
		if isByteSlice(t) {
			return typeGenInfo{
				TestGenerator: "gen.GenerateBytes(depth - 1)",
				TestComparer:  "gen.CompareBytes",
			}
		}
		eltInfo := g.getJSTypeInfo(t.Elt)
		return typeGenInfo{
			TestGenerator: fmt.Sprintf("gen.GenerateSlice(depth - 1, (d) => %s)", eltInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("(a, b) => gen.CompareSlice(a, b, %s)", eltInfo.TestComparer),
		}
	case *ast.MapType:
		keyInfo := g.getJSTypeInfo(t.Key)
		valInfo := g.getJSTypeInfo(t.Value)
		return typeGenInfo{
			TestGenerator: fmt.Sprintf("gen.GenerateMap(depth - 1, (d) => %s, (d) => %s)", keyInfo.TestGenerator, valInfo.TestGenerator),
			TestComparer:  fmt.Sprintf("(a, b) => gen.CompareMap(a, b, %s)", valInfo.TestComparer),
		}
	case *ast.SelectorExpr:
		if g.ExprToString(t) == "time.Time" {
			return typeGenInfo{
				TestGenerator: "gen.GenerateTime(depth - 1)",
				TestComparer:  "gen.ComparePrimitive",
			}
		}
	}
	return typeGenInfo{TestGenerator: "null", TestComparer: "(a,b) => null"}
}

func isByteSlice(t *ast.ArrayType) bool {
	if ident, ok := t.Elt.(*ast.Ident); ok {
		return ident.Name == "byte" || ident.Name == "uint8"
	}
	return false
}

func isBasicType(expr ast.Expr) bool {
	if ident, ok := expr.(*ast.Ident); ok {
		return common.FixedSizeTypes[ident.Name] || ident.Name == "string"
	}
	return false
}