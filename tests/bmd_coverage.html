
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/deneonet/benc/bmd/bmd.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bmd

import (
        "fmt"
        "math"
        "unsafe"

        "github.com/deneonet/benc"
        "golang.org/x/exp/constraints"
)

const (
        Int16 byte = iota
        Int32
        Int64
        UInt16
        UInt32
        UInt64
        Float32
        Float64
        Bool
        Byte
        String
        Slice
        Map
        ByteSlice
)

const AllowedDataTypeStartID = 14

//nolint:funlen
func GetDataTypeName(dataType byte) string <span class="cov8" title="1">{
        switch dataType </span>{
        case Int16:<span class="cov0" title="0">
                return "Int16"</span>
        case Int32:<span class="cov0" title="0">
                return "Int32"</span>
        case Int64:<span class="cov0" title="0">
                return "Int64"</span>
        case UInt16:<span class="cov0" title="0">
                return "Uint16"</span>
        case UInt32:<span class="cov0" title="0">
                return "Uint32"</span>
        case UInt64:<span class="cov0" title="0">
                return "Uint64"</span>
        case Float32:<span class="cov0" title="0">
                return "Float32"</span>
        case Float64:<span class="cov0" title="0">
                return "Float64"</span>
        case Bool:<span class="cov8" title="1">
                return "Bool"</span>
        case Byte:<span class="cov8" title="1">
                return "Byte"</span>
        case String:<span class="cov0" title="0">
                return "String"</span>
        case Slice:<span class="cov0" title="0">
                return "Slice"</span>
        case Map:<span class="cov0" title="0">
                return "Map"</span>
        case ByteSlice:<span class="cov0" title="0">
                return "Byte slice"</span>
        default:<span class="cov0" title="0">
                return "Invalid"</span>
        }
}

type SkipFunc func(n int, b []byte) (int, error)
type UnmarshalFunc[T any] func(n int, b []byte) (int, T, error)

// For unsafe string too
func SkipString(n int, b []byte) (int, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != String </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected String, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        return n + v, nil</span>
}

// For unsafe string too
func SizeString(str string, ms ...int) (int, error) <span class="cov8" title="1">{
        s := 2
        v := len(str)
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 8:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `SizeString`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">return v + s + 2, nil</span>
}

func MarshalString(n int, b []byte, str string, ms ...int) (int, error) <span class="cov8" title="1">{
        b[n] = String
        n++

        s := 2
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">b[n] = byte(s)
        n++

        v := len(str)
        u := b[n : n+s]
        switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[1]
                u[0] = byte(v)
                u[1] = byte(v &gt;&gt; 8)</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[3]
                v32 := uint32(v)
                u[0] = byte(v32)
                u[1] = byte(v32 &gt;&gt; 8)
                u[2] = byte(v32 &gt;&gt; 16)
                u[3] = byte(v32 &gt;&gt; 24)</span>
        case 8:<span class="cov0" title="0">
                _ = u[7]
                v64 := uint64(v)
                u[0] = byte(v64)
                u[1] = byte(v64 &gt;&gt; 8)
                u[2] = byte(v64 &gt;&gt; 16)
                u[3] = byte(v64 &gt;&gt; 24)
                u[4] = byte(v64 &gt;&gt; 32)
                u[5] = byte(v64 &gt;&gt; 40)
                u[6] = byte(v64 &gt;&gt; 48)
                u[7] = byte(v64 &gt;&gt; 56)</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `MarshalString`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">n += s
        return n + copy(b[n:], str), nil</span>
}

func UnmarshalString(n int, b []byte) (int, string, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, "", benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != String </span><span class="cov8" title="1">{
                return n, "", fmt.Errorf("type mismatch: expected String, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, "", benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, "", benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, "", benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        bs := b[n : n+v]
        return n + v, string(bs), nil</span>
}

//

type StringHeader struct {
        Data *byte
        Len  int
}

// b2s converts byte slice to a string without memory allocation.
//
// Previously used: -- return *(*string)(unsafe.Pointer(&amp;b))
//
// Removed because reflect.SliceHeader is deprecated, so I use unsafe.String
// see https://github.com/golang/go/issues/53003
func b2s(b []byte) string <span class="cov8" title="1">{
        return unsafe.String(&amp;b[0], len(b))
}</span>

// s2b converts string to a byte slice without memory allocation.
//
// Previously used: -- *(*[]byte)(unsafe.Pointer(&amp;s))
//
// Removed because of: https://github.com/golang/go/issues/53003
// +
// because reflect.StringHeader is deprecated, so I use a new StringHeader type
// see https://github.com/golang/go/issues/53003#issuecomment-1145241692
func s2b(s string) []byte <span class="cov8" title="1">{
        header := (*StringHeader)(unsafe.Pointer(&amp;s))
        bytes := *(*[]byte)(unsafe.Pointer(header))
        return bytes
}</span>

func MarshalUnsafeString(n int, b []byte, str string, ms ...int) (int, error) <span class="cov8" title="1">{
        b[n] = String
        n++

        s := 2
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">b[n] = byte(s)
        n++

        v := len(str)
        u := b[n : n+s]

        switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[1]
                u[0] = byte(v)
                u[1] = byte(v &gt;&gt; 8)</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[3]
                v32 := uint32(v)
                u[0] = byte(v32)
                u[1] = byte(v32 &gt;&gt; 8)
                u[2] = byte(v32 &gt;&gt; 16)
                u[3] = byte(v32 &gt;&gt; 24)</span>
        case 8:<span class="cov0" title="0">
                _ = u[7]
                v64 := uint64(v)
                u[0] = byte(v64)
                u[1] = byte(v64 &gt;&gt; 8)
                u[2] = byte(v64 &gt;&gt; 16)
                u[3] = byte(v64 &gt;&gt; 24)
                u[4] = byte(v64 &gt;&gt; 32)
                u[5] = byte(v64 &gt;&gt; 40)
                u[6] = byte(v64 &gt;&gt; 48)
                u[7] = byte(v64 &gt;&gt; 56)</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `MarshalString`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">n += s
        return n + copy(b[n:], s2b(str)), nil</span>
}

func UnmarshalUnsafeString(n int, b []byte) (int, string, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, "", benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != String </span><span class="cov8" title="1">{
                return n, "", fmt.Errorf("type mismatch: expected String, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, "", benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, "", benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if v == 0 </span><span class="cov8" title="1">{
                return n + s, "", nil
        }</span>
        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, "", benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        bs := b[n : n+v]
        return n + v, b2s(bs), nil</span>
}

//

func SkipSlice(n int, b []byte, skipper SkipFunc) (int, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != Slice </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Slice, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        var err error
        for i := 0; i &lt; v; i++ </span><span class="cov8" title="1">{
                n, err = skipper(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, fmt.Errorf("at index %d: %s", i, err.Error())
                }</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

func SizeSlice[T any](slice []T, sizer interface{}, ms ...int) (int, error) <span class="cov8" title="1">{
        s := 2
        v := len(slice)
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 8:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `SizeSlice`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">var ts int
        var err error

        for i, t := range slice </span><span class="cov8" title="1">{
                switch p := sizer.(type) </span>{
                case func() int:<span class="cov8" title="1">
                        s += p()</span>
                case func(T) (int, error):<span class="cov0" title="0">
                        ts, err = p(t)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov0" title="0">s += ts</span>
                case func(T, ...int) (int, error):<span class="cov8" title="1">
                        ts, err = p(t)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov8" title="1">s += ts</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `sizer` provided in `SizeSlice`")</span>
                }
        }

        <span class="cov8" title="1">return s + 2, nil</span>
}

func MarshalSlice[T any](n int, b []byte, slice []T, marshaler interface{}, ms ...int) (int, error) <span class="cov8" title="1">{
        b[n] = Slice
        n++

        s := 2
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">b[n] = byte(s)
        n++

        v := len(slice)
        u := b[n : n+s]

        switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[1]
                u[0] = byte(v)
                u[1] = byte(v &gt;&gt; 8)</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[3]
                v32 := uint32(v)
                u[0] = byte(v32)
                u[1] = byte(v32 &gt;&gt; 8)
                u[2] = byte(v32 &gt;&gt; 16)
                u[3] = byte(v32 &gt;&gt; 24)</span>
        case 8:<span class="cov0" title="0">
                _ = u[7]
                v64 := uint64(v)
                u[0] = byte(v64)
                u[1] = byte(v64 &gt;&gt; 8)
                u[2] = byte(v64 &gt;&gt; 16)
                u[3] = byte(v64 &gt;&gt; 24)
                u[4] = byte(v64 &gt;&gt; 32)
                u[5] = byte(v64 &gt;&gt; 40)
                u[6] = byte(v64 &gt;&gt; 48)
                u[7] = byte(v64 &gt;&gt; 56)</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `MarshalSlice`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">n += s
        var err error
        for i, t := range slice </span><span class="cov8" title="1">{
                switch p := marshaler.(type) </span>{
                case func(n int, b []byte, t T) int:<span class="cov8" title="1">
                        n = p(n, b, t)</span>
                case func(n int, b []byte, t T) (int, error):<span class="cov0" title="0">
                        n, err = p(n, b, t)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("at index %d: %s", i, err.Error())
                        }</span>
                case func(n int, b []byte, t T, ms ...int) (int, error):<span class="cov8" title="1">
                        n, err = p(n, b, t)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("at index %d: %s", i, err.Error())
                        }</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `marshaler` provided in `MarshalSlice`")</span>
                }
        }
        <span class="cov8" title="1">return n, nil</span>
}

func UnmarshalSlice[T any](n int, b []byte, unmarshaler UnmarshalFunc[T]) (int, []T, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != Slice </span><span class="cov0" title="0">{
                return n, nil, fmt.Errorf("type mismatch: expected Slice, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s

        var t T
        var err error

        ts := make([]T, v)

        for i := 0; i &lt; v; i++ </span><span class="cov8" title="1">{
                n, t, err = unmarshaler(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, nil, fmt.Errorf("at index %d: %s", i, err.Error())
                }</span>

                <span class="cov8" title="1">ts[i] = t</span>
        }

        <span class="cov8" title="1">return n, ts, nil</span>
}

// TODO: Do the max size thing wingy

func SkipMap(n int, b []byte, kSkipper SkipFunc, vSkipper SkipFunc) (int, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != Map </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Map, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        var err error
        for i := 0; i &lt; v; i++ </span><span class="cov8" title="1">{
                n, err = kSkipper(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                }</span>

                <span class="cov8" title="1">n, err = vSkipper(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                }</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

func SizeMap[K comparable, V any](m map[K]V, kSizer interface{}, vSizer interface{}, ms ...int) (int, error) <span class="cov8" title="1">{
        s := 2
        v := len(m)
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 8:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `SizeMap`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">var ts int
        var err error

        var i int
        for k, v := range m </span><span class="cov8" title="1">{
                switch p := kSizer.(type) </span>{
                case func() int:<span class="cov8" title="1">
                        s += p()</span>
                case func(K) (int, error):<span class="cov0" title="0">
                        ts, err = p(k)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov0" title="0">s += ts</span>
                case func(K, ...int) (int, error):<span class="cov8" title="1">
                        ts, err = p(k)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov8" title="1">s += ts</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `kSizer` provided in `SizeMap`")</span>
                }

                <span class="cov8" title="1">switch p := vSizer.(type) </span>{
                case func() int:<span class="cov8" title="1">
                        s += p()</span>
                case func(V) (int, error):<span class="cov0" title="0">
                        ts, err = p(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov0" title="0">s += ts</span>
                case func(V, ...int) (int, error):<span class="cov8" title="1">
                        ts, err = p(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                        }</span>
                        <span class="cov8" title="1">s += ts</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `vSizer` provided in `SizeMap`")</span>
                }
                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">return s + 2, nil</span>
}

func MarshalMap[K comparable, V any](n int, b []byte, m map[K]V, kMarshaler interface{}, vMarshaler interface{}, ms ...int) (int, error) <span class="cov8" title="1">{
        b[n] = Map
        n++

        s := 2
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">b[n] = byte(s)
        n++

        v := len(m)
        u := b[n : n+s]

        switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[1]
                u[0] = byte(v)
                u[1] = byte(v &gt;&gt; 8)</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[3]
                v32 := uint32(v)
                u[0] = byte(v32)
                u[1] = byte(v32 &gt;&gt; 8)
                u[2] = byte(v32 &gt;&gt; 16)
                u[3] = byte(v32 &gt;&gt; 24)</span>
        case 8:<span class="cov0" title="0">
                _ = u[7]
                v64 := uint64(v)
                u[0] = byte(v64)
                u[1] = byte(v64 &gt;&gt; 8)
                u[2] = byte(v64 &gt;&gt; 16)
                u[3] = byte(v64 &gt;&gt; 24)
                u[4] = byte(v64 &gt;&gt; 32)
                u[5] = byte(v64 &gt;&gt; 40)
                u[6] = byte(v64 &gt;&gt; 48)
                u[7] = byte(v64 &gt;&gt; 56)</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `MarshalMap`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">n += s
        var err error
        var i int
        for k, v := range m </span><span class="cov8" title="1">{
                switch p := kMarshaler.(type) </span>{
                case func(n int, b []byte, k K) int:<span class="cov8" title="1">
                        n = p(n, b, k)</span>
                case func(n int, b []byte, k K) (int, error):<span class="cov0" title="0">
                        n, err = p(n, b, k)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                        }</span>
                case func(n int, b []byte, k K, ms ...int) (int, error):<span class="cov8" title="1">
                        n, err = p(n, b, k)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                        }</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `kMarshaler` provided in `MarshalMap`")</span>
                }

                <span class="cov8" title="1">switch p := vMarshaler.(type) </span>{
                case func(n int, b []byte, v V) int:<span class="cov8" title="1">
                        n = p(n, b, v)</span>
                case func(n int, b []byte, v V) (int, error):<span class="cov0" title="0">
                        n, err = p(n, b, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                        }</span>
                case func(n int, b []byte, v V, ms ...int) (int, error):<span class="cov8" title="1">
                        n, err = p(n, b, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                        }</span>
                default:<span class="cov0" title="0">
                        panic("[benc " + benc.BencVersion + "]: invalid `vMarshaler` provided in `MarshalMap`")</span>
                }

                <span class="cov8" title="1">i++</span>
        }
        <span class="cov8" title="1">return n, nil</span>
}

func UnmarshalMap[K comparable, V any](n int, b []byte, kUnmarshaler UnmarshalFunc[K], vUnmarshaler UnmarshalFunc[V]) (int, map[K]V, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != Map </span><span class="cov0" title="0">{
                return n, nil, fmt.Errorf("type mismatch: expected Map, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s

        var k K
        var val V
        var err error

        ts := make(map[K]V, v)

        for i := 0; i &lt; v; i++ </span><span class="cov8" title="1">{
                n, k, err = kUnmarshaler(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, nil, fmt.Errorf("(key) at index %d: %s", i, err.Error())
                }</span>

                <span class="cov8" title="1">n, val, err = vUnmarshaler(n, b)
                if err != nil </span><span class="cov0" title="0">{
                        return n, nil, fmt.Errorf("(value) at index %d: %s", i, err.Error())
                }</span>

                <span class="cov8" title="1">ts[k] = val</span>
        }

        <span class="cov8" title="1">return n, ts, nil</span>
}

//

func SkipByte(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Byte </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Byte, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 2, nil</span>
}

func SizeByte() int <span class="cov8" title="1">{
        return 2
}</span>

func MarshalByte(n int, b []byte, byt byte) int <span class="cov8" title="1">{
        b[n] = Byte
        b[n+1] = byt
        return n + 2
}</span>

func UnmarshalByte(n int, b []byte) (int, byte, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 2 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Byte </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Byte, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        return n + 1, b[n], nil</span>
}

//

func SkipByteSlice(n int, b []byte) (int, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != ByteSlice </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected ByteSlice, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        return n + v, nil</span>
}

func SizeByteSlice(bs []byte, ms ...int) (int, error) <span class="cov8" title="1">{
        s := 2
        v := len(bs)
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return 0, benc.ErrDataTooBig
                }</span>
        case 8:<span class="cov0" title="0">
                break</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `SizeByteSlice`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">return v + s + 2, nil</span>
}

func MarshalByteSlice(n int, b []byte, bs []byte, ms ...int) (int, error) <span class="cov8" title="1">{
        b[n] = ByteSlice
        n++

        s := 2
        if len(ms) == 1 </span><span class="cov8" title="1">{
                s = ms[0]
        }</span>

        <span class="cov8" title="1">b[n] = byte(s)
        n++

        v := len(bs)
        u := b[n : n+s]

        switch s </span>{
        case 2:<span class="cov8" title="1">
                if v &gt; math.MaxUint16 </span><span class="cov8" title="1">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[1]
                u[0] = byte(v)
                u[1] = byte(v &gt;&gt; 8)</span>
        case 4:<span class="cov8" title="1">
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        return n - 1, benc.ErrDataTooBig
                }</span>

                <span class="cov8" title="1">_ = u[3]
                v32 := uint32(v)
                u[0] = byte(v32)
                u[1] = byte(v32 &gt;&gt; 8)
                u[2] = byte(v32 &gt;&gt; 16)
                u[3] = byte(v32 &gt;&gt; 24)</span>
        case 8:<span class="cov0" title="0">
                _ = u[7]
                v64 := uint64(v)
                u[0] = byte(v64)
                u[1] = byte(v64 &gt;&gt; 8)
                u[2] = byte(v64 &gt;&gt; 16)
                u[3] = byte(v64 &gt;&gt; 24)
                u[4] = byte(v64 &gt;&gt; 32)
                u[5] = byte(v64 &gt;&gt; 40)
                u[6] = byte(v64 &gt;&gt; 48)
                u[7] = byte(v64 &gt;&gt; 56)</span>
        default:<span class="cov0" title="0">
                panic("[benc " + benc.BencVersion + "]: invalid `ms` provided in `MarshalByteSlice`: allowed values, are: 2, 4 and 8")</span>
        }

        <span class="cov8" title="1">n += s
        return n + copy(b[n:], bs), nil</span>
}

func UnmarshalByteSlice(n int, b []byte) (int, []byte, error) <span class="cov8" title="1">{
        lb := len(b) - n
        if lb &lt; 2 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">dt := b[n]
        if dt != ByteSlice </span><span class="cov8" title="1">{
                return n, nil, fmt.Errorf("type mismatch: expected ByteSlice, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++

        s := int(b[n])
        n++

        if s != 2 &amp;&amp; s != 4 &amp;&amp; s != 8 </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidSize
        }</span>
        <span class="cov8" title="1">if lb-2 &lt; s </span><span class="cov8" title="1">{
                return n, nil, benc.ErrBufTooSmall
        }</span>

        <span class="cov8" title="1">u := b[n : n+s]
        v := 0

        switch s </span>{
        case 2:<span class="cov8" title="1">
                v = int(uint16(u[0]) | uint16(u[1])&lt;&lt;8)</span>
        case 4:<span class="cov8" title="1">
                _ = u[3]
                v = int(uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24)</span>
        case 8:<span class="cov8" title="1">
                _ = u[7]
                v = int(uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                        uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56)</span>
        }

        <span class="cov8" title="1">if lb-s-2 &lt; v </span><span class="cov8" title="1">{
                return n, nil, benc.ErrInvalidData
        }</span>

        <span class="cov8" title="1">n += s
        return n + v, b[n : n+v], nil</span>
}

//

func SkipUInt64(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt64 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Uint64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 9, nil</span>
}

func SizeUInt64() int <span class="cov8" title="1">{
        return 9
}</span>

func MarshalUInt64(n int, b []byte, v uint64) int <span class="cov8" title="1">{
        b[n] = UInt64
        n++

        u := b[n : n+8]
        _ = u[7]
        u[0] = byte(v)
        u[1] = byte(v &gt;&gt; 8)
        u[2] = byte(v &gt;&gt; 16)
        u[3] = byte(v &gt;&gt; 24)
        u[4] = byte(v &gt;&gt; 32)
        u[5] = byte(v &gt;&gt; 40)
        u[6] = byte(v &gt;&gt; 48)
        u[7] = byte(v &gt;&gt; 56)
        return n + 8
}</span>

func UnmarshalUInt64(n int, b []byte) (int, uint64, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt64 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Uint64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+8]
        _ = u[7]
        v := uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56
        return n + 8, v, nil</span>
}

//

func SkipUInt32(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Uint32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 5, nil</span>
}

func SizeUInt32() int <span class="cov8" title="1">{
        return 5
}</span>

func MarshalUInt32(n int, b []byte, v uint32) int <span class="cov8" title="1">{
        b[n] = UInt32
        n++

        u := b[n : n+4]
        _ = u[3]
        u[0] = byte(v)
        u[1] = byte(v &gt;&gt; 8)
        u[2] = byte(v &gt;&gt; 16)
        u[3] = byte(v &gt;&gt; 24)
        return n + 4
}</span>

func UnmarshalUInt32(n int, b []byte) (int, uint32, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt32 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Uint32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+4]
        _ = u[3]
        v := uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24
        return n + 4, v, nil</span>
}

//

func SkipUInt16(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 3 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt16 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Uint16, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 3, nil</span>
}

func SizeUInt16() int <span class="cov8" title="1">{
        return 3
}</span>

func MarshalUInt16(n int, b []byte, v uint16) int <span class="cov8" title="1">{
        b[n] = UInt16
        n++

        u := b[n : n+2]
        _ = u[1]
        u[0] = byte(v)
        u[1] = byte(v &gt;&gt; 8)
        return n + 2
}</span>

func UnmarshalUInt16(n int, b []byte) (int, uint16, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 3 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != UInt16 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Uint16, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+2]
        _ = u[1]
        v := uint16(u[0]) | uint16(u[1])&lt;&lt;8
        return n + 2, v, nil</span>
}

//

func SkipInt64(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int64 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Int64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 9, nil</span>
}

func SizeInt64() int <span class="cov8" title="1">{
        return 9
}</span>

func MarshalInt64(n int, b []byte, v int64) int <span class="cov8" title="1">{
        b[n] = Int64
        n++

        v64 := uint64(EncodeZigZag(v))
        u := b[n : n+8]
        _ = u[7]
        u[0] = byte(v64)
        u[1] = byte(v64 &gt;&gt; 8)
        u[2] = byte(v64 &gt;&gt; 16)
        u[3] = byte(v64 &gt;&gt; 24)
        u[4] = byte(v64 &gt;&gt; 32)
        u[5] = byte(v64 &gt;&gt; 40)
        u[6] = byte(v64 &gt;&gt; 48)
        u[7] = byte(v64 &gt;&gt; 56)
        return n + 8
}</span>

func UnmarshalInt64(n int, b []byte) (int, int64, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int64 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Int64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+8]
        _ = u[7]
        v := uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56
        return n + 8, int64(DecodeZigZag(v)), nil</span>
}

//

func SkipInt32(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Int32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 5, nil</span>
}

func SizeInt32() int <span class="cov8" title="1">{
        return 5
}</span>

func MarshalInt32(n int, b []byte, v int32) int <span class="cov8" title="1">{
        b[n] = Int32
        n++

        v32 := uint32(EncodeZigZag(v))
        u := b[n : n+4]
        _ = u[3]
        u[0] = byte(v32)
        u[1] = byte(v32 &gt;&gt; 8)
        u[2] = byte(v32 &gt;&gt; 16)
        u[3] = byte(v32 &gt;&gt; 24)
        return n + 4
}</span>

func UnmarshalInt32(n int, b []byte) (int, int32, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int32 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Int32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+4]
        _ = u[3]
        v := uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24
        return n + 4, int32(DecodeZigZag(v)), nil</span>
}

//

func SkipInt16(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 3 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int16 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Int16, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 3, nil</span>
}

func SizeInt16() int <span class="cov8" title="1">{
        return 3
}</span>

func MarshalInt16(n int, b []byte, v int16) int <span class="cov8" title="1">{
        b[n] = Int16
        n++

        v16 := uint16(EncodeZigZag(v))
        u := b[n : n+2]
        _ = u[1]
        u[0] = byte(v16)
        u[1] = byte(v16 &gt;&gt; 8)
        return n + 2
}</span>

func UnmarshalInt16(n int, b []byte) (int, int16, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 3 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Int16 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Int16, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+2]
        _ = u[1]
        v := uint16(u[0]) | uint16(u[1])&lt;&lt;8
        return n + 2, int16(DecodeZigZag(v)), nil</span>
}

//

func SkipFloat64(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Float64 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Float64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 9, nil</span>
}

func SizeFloat64() int <span class="cov8" title="1">{
        return 9
}</span>

func MarshalFloat64(n int, b []byte, v float64) int <span class="cov8" title="1">{
        b[n] = Float64
        n++

        v64 := math.Float64bits(v)
        u := b[n : n+8]
        _ = u[7]
        u[0] = byte(v64)
        u[1] = byte(v64 &gt;&gt; 8)
        u[2] = byte(v64 &gt;&gt; 16)
        u[3] = byte(v64 &gt;&gt; 24)
        u[4] = byte(v64 &gt;&gt; 32)
        u[5] = byte(v64 &gt;&gt; 40)
        u[6] = byte(v64 &gt;&gt; 48)
        u[7] = byte(v64 &gt;&gt; 56)
        return n + 8
}</span>

func UnmarshalFloat64(n int, b []byte) (int, float64, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 9 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Float64 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Float64, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+8]
        _ = u[7]
        v := uint64(u[0]) | uint64(u[1])&lt;&lt;8 | uint64(u[2])&lt;&lt;16 | uint64(u[3])&lt;&lt;24 |
                uint64(u[4])&lt;&lt;32 | uint64(u[5])&lt;&lt;40 | uint64(u[6])&lt;&lt;48 | uint64(u[7])&lt;&lt;56
        return n + 8, math.Float64frombits(v), nil</span>
}

//

func SkipFloat32(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Float32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Float32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 5, nil</span>
}

func SizeFloat32() int <span class="cov8" title="1">{
        return 5
}</span>

func MarshalFloat32(n int, b []byte, v float32) int <span class="cov8" title="1">{
        b[n] = Float32
        n++

        v32 := math.Float32bits(v)
        u := b[n : n+4]
        _ = u[3]
        u[0] = byte(v32)
        u[1] = byte(v32 &gt;&gt; 8)
        u[2] = byte(v32 &gt;&gt; 16)
        u[3] = byte(v32 &gt;&gt; 24)
        return n + 4
}</span>

func UnmarshalFloat32(n int, b []byte) (int, float32, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 5 </span><span class="cov8" title="1">{
                return n, 0, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Float32 </span><span class="cov8" title="1">{
                return n, 0, fmt.Errorf("type mismatch: expected Float32, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        u := b[n : n+4]
        _ = u[3]
        v := uint32(u[0]) | uint32(u[1])&lt;&lt;8 | uint32(u[2])&lt;&lt;16 | uint32(u[3])&lt;&lt;24
        return n + 4, math.Float32frombits(v), nil</span>
}

//

func SkipBool(n int, b []byte) (int, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 2 </span><span class="cov8" title="1">{
                return n, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Bool </span><span class="cov0" title="0">{
                return n, fmt.Errorf("type mismatch: expected Bool, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">return n + 2, nil</span>
}

func SizeBool() int <span class="cov8" title="1">{
        return 2
}</span>

func MarshalBool(n int, b []byte, v bool) int <span class="cov8" title="1">{
        b[n] = Bool
        n++
        var i byte
        if v </span><span class="cov8" title="1">{
                i = 1
        }</span>
        <span class="cov8" title="1">b[n] = i
        return n + 1</span>
}

func UnmarshalBool(n int, b []byte) (int, bool, error) <span class="cov8" title="1">{
        if len(b)-n &lt; 2 </span><span class="cov8" title="1">{
                return n, false, benc.ErrBufTooSmall
        }</span>
        <span class="cov8" title="1">dt := b[n]
        if dt != Bool </span><span class="cov8" title="1">{
                return n, false, fmt.Errorf("type mismatch: expected Bool, got %s", GetDataTypeName(dt))
        }</span>
        <span class="cov8" title="1">n++
        return n + 1, uint8(b[n]) == 1, nil</span>
}

//

func EncodeZigZag[T constraints.Signed](t T) T <span class="cov8" title="1">{
        if t &lt; 0 </span><span class="cov0" title="0">{
                return ^(t &lt;&lt; 1)
        }</span>
        <span class="cov8" title="1">return t &lt;&lt; 1</span>
}

func DecodeZigZag[T constraints.Unsigned](t T) T <span class="cov8" title="1">{
        if t&amp;1 == 1 </span><span class="cov0" title="0">{
                return ^(t &gt;&gt; 1)
        }</span>
        <span class="cov8" title="1">return t &gt;&gt; 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
